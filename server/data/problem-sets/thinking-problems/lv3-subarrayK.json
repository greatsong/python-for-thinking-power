{
  "id": "lv3-subarrayK",
  "title": "연속 부분합 K 찾기",
  "difficulty": 3,
  "category": "algorithm",
  "description": "## 🎯 연속 부분합 K 찾기\n\n배열에서 **연속된 원소들의 합**이 정확히 K가 되는 구간을 찾아요.\n\n```\n배열: [1, 3, 2, 5, 1, 1, 2, 3]\nK = 8\n\n[1, 3, 2, 5] → 합 11 ❌\n[3, 2, 5] → 합 10 ❌\n[2, 5, 1] → 합 8 ✅ → 인덱스 2~4\n```\n\n> 모든 구간을 다 확인하면? 🐢\n> 창문처럼 밀면서 확인하면? 🪟\n> 누적합의 차이로 계산하면? 📐\n\n---\n\n### 입력\n첫째 줄에 N K (1 ≤ N ≤ 10,000), 둘째 줄에 N개의 양의 정수가 공백으로 주어져요.\n\n### 출력\n합이 K인 연속 부분배열의 시작 인덱스와 끝 인덱스(0-based)를 출력하세요.\n여러 개면 가장 먼저 시작하는 것, 시작이 같으면 가장 짧은 것.\n없으면 `-1`을 출력하세요.\n\n### 예시 1\n```\n입력:\n8 8\n1 3 2 5 1 1 2 3\n출력: 2 4\n```\n> [2, 5, 1] = 8, 인덱스 2~4\n\n### 예시 2\n```\n입력:\n5 100\n1 2 3 4 5\n출력: -1\n```\n\n### 생각해 볼 점 💡\n\n양의 정수만 있으면, 오른쪽을 늘릴수록 합이 커져요.\n이 **단조성**을 이용하면 훨씬 빠르게 찾을 수 있지 않을까요? 🤔",
  "starter_code": "n, k = map(int, input().split())\narr = list(map(int, input().split()))\n\n# 합이 k인 연속 부분배열의 시작/끝 인덱스를 찾으세요\n",
  "test_cases": [
    { "input": "8 8\n1 3 2 5 1 1 2 3", "expected_output": "2 4", "description": "[2,5,1]=8" },
    { "input": "5 100\n1 2 3 4 5", "expected_output": "-1", "description": "합이 100인 구간 없음" },
    { "input": "5 5\n5 1 2 3 4", "expected_output": "0 0", "description": "첫 원소 하나가 5" },
    { "input": "6 10\n1 2 3 4 5 6", "expected_output": "0 3", "description": "[1,2,3,4]=10" },
    { "input": "10 15\n3 1 4 1 5 9 2 6 5 3", "expected_output": "3 5", "description": "[1,5,9]=15" }
  ],
  "hints": [
    "가장 단순한 방법: 모든 시작점 i, 끝점 j 쌍에 대해 합을 구해보면?",
    "양의 정수이므로 합이 K를 넘으면 왼쪽을 줄이고, 부족하면 오른쪽을 늘려봐요.",
    "누적합 prefix[i] = arr[0]+...+arr[i-1]이면, 구간 합 = prefix[j+1] - prefix[i]"
  ],
  "expected_approaches": [
    { "tag": "완전 탐색 O(n²)", "description": "모든 (시작, 끝) 쌍의 합을 구해서 K와 비교" },
    { "tag": "슬라이딩 윈도우 O(n)", "description": "양수 배열이므로 투 포인터로 합 조절 — 합이 크면 왼쪽 줄이고, 작으면 오른쪽 늘리기" },
    { "tag": "누적합 + 해시맵 O(n)", "description": "prefix[j] - prefix[i] = K인 i를 해시맵으로 O(1)에 찾기" }
  ],
  "explanation": "## 풀이 해설\n\n### 접근법 1: 완전 탐색\n\n모든 시작점과 끝점 쌍을 확인해요.\n\n```python\nn, k = map(int, input().split())\narr = list(map(int, input().split()))\n\nfor i in range(n):\n    total = 0\n    for j in range(i, n):\n        total += arr[j]\n        if total == k:\n            print(i, j)\n            exit()\n\nprint(-1)\n```\n\n> **생각의 방식**: \"다 확인하자!\" — 모든 시작점 × 모든 끝점, O(n²)\n\n---\n\n### 접근법 2: 슬라이딩 윈도우\n\n창문을 오른쪽으로 밀면서 크기를 조절해요.\n\n```python\nn, k = map(int, input().split())\narr = list(map(int, input().split()))\n\nleft = 0\ncurrent_sum = 0\n\nfor right in range(n):\n    current_sum += arr[right]       # 오른쪽 확장\n    \n    while current_sum > k and left <= right:\n        current_sum -= arr[left]    # 왼쪽 축소\n        left += 1\n    \n    if current_sum == k:\n        print(left, right)\n        exit()\n\nprint(-1)\n```\n\n> **생각의 방식**: \"창문을 밀자!\" — 양의 정수이므로 오른쪽을 늘리면 합이 커지고, 왼쪽을 줄이면 작아져요. 이 **단조성** 덕분에 left, right 각각 최대 n번만 이동 → O(n)!\n\n---\n\n### 접근법 3: 누적합 + 해시맵\n\n구간 합 = 누적합의 차이라는 수학적 성질을 이용해요.\n\n```python\nn, k = map(int, input().split())\narr = list(map(int, input().split()))\n\nprefix_map = {0: -1}  # 누적합 → 인덱스\ncurrent_sum = 0\n\nfor j in range(n):\n    current_sum += arr[j]\n    need = current_sum - k\n    \n    if need in prefix_map:\n        i = prefix_map[need] + 1\n        print(i, j)\n        exit()\n    \n    if current_sum not in prefix_map:\n        prefix_map[current_sum] = j\n\nprint(-1)\n```\n\n> **생각의 방식**: \"세지 말고 계산하자!\" — `arr[i]+...+arr[j] = prefix[j+1] - prefix[i] = K`이면 `prefix[i] = prefix[j+1] - K`. 이걸 해시맵에서 O(1)에 찾기!\n> 이 방법은 **음수가 있어도 작동**해요. (슬라이딩 윈도우는 양수만!)\n\n---\n\n### 비교 포인트 🔍\n\n| | 완전 탐색 | 슬라이딩 윈도우 | 누적합+해시맵 |\n|---|---|---|---|\n| 반복 횟수 | n²번 | **n번** | **n번** |\n| 추가 공간 | 없음 | 없음 | O(n) |\n| 음수 지원 | ✅ | ❌ | ✅ |\n| 생각 방식 | 다 확인 | 창문 밀기 | 수학적 변환 |\n\nn=10,000일 때: 완전 탐색 ~0.5초, 나머지 둘 ~0.001초 → **500배 차이!**\n\n세 방법 모두 같은 답을 내지만, **생각의 경로**가 완전히 달라요!\n- 접근법 1: \"모든 구간을 다 확인하자\" (전수 조사)\n- 접근법 2: \"양수니까 창문을 밀자\" (단조성 활용)\n- 접근법 3: \"구간 합 = 누적합의 차이!\" (수학적 변환)"
}
