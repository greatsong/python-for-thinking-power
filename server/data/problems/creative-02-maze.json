{
  "id": "creative-02-maze",
  "title": "미로 탈출 로봇",
  "difficulty": 5,
  "category": "algorithm",
  "description": "## 미로 탈출 로봇\n\n탈출 로봇 '파이보'가 N x N 격자 미로에 갇혀 있습니다! 파이보는 **왼쪽 위 (0,0)**에서 출발해서 **오른쪽 아래 (N-1, N-1)**까지 도달해야 합니다.\n\n### 규칙\n- 파이보는 **오른쪽** 또는 **아래쪽**으로만 이동할 수 있습니다\n- 격자에서 `0`은 이동 가능, `1`은 벽(장애물)입니다\n- 시작점과 도착점은 항상 `0`입니다\n- 가능한 **경로의 수**를 구하세요\n\n```mermaid\nflowchart TD\n    subgraph 3x3 격자 미로\n        A[\"(0,0) 시작 ✓\"] -->|오른쪽| B[\"(0,1) ✓\"]\n        A -->|아래| D[\"(1,0) ✓\"]\n        B -->|오른쪽| C[\"(0,2) ✓\"]\n        B -->|아래| E[\"(1,1) 벽 ✗\"]\n        C -->|아래| F[\"(1,2) ✓\"]\n        D -->|아래| G[\"(2,0) ✓\"]\n        D -->|오른쪽| E\n        F -->|아래| I[\"(2,2) 도착 🏁\"]\n        G -->|오른쪽| H[\"(2,1) ✓\"]\n        H -->|오른쪽| I\n    end\n```\n\n위 예시에서 (1,1)이 벽이므로, 가능한 경로는 2가지:\n1. → → ↓ ↓ (위로 돌아서)\n2. ↓ ↓ → → (아래로 돌아서)\n\n### 핵심 아이디어: 동적 프로그래밍(DP)\n\n각 칸에 도달하는 경로 수 = **위에서 오는 경로 수** + **왼쪽에서 오는 경로 수**\n\n```\n격자:          DP 테이블:\n0 0 0          1 1 1\n0 1 0    →     1 0 1\n0 0 0          1 1 2\n```\n\n### 입력\n- 첫 줄: 격자 크기 N\n- 다음 N줄: 각 줄에 N개의 숫자 (0 또는 1, 공백 구분)\n\n### 출력\n- 가능한 경로의 수\n\n### 예시\n\n**예시 1:**\n```\n입력:\n3\n0 0 0\n0 1 0\n0 0 0\n\n출력:\n2\n```\n> 가운데가 막혀있어서 위로 돌거나 아래로 돌아야 함 → 2가지\n\n**예시 2:**\n```\n입력:\n3\n0 0 0\n0 0 0\n0 0 0\n\n출력:\n6\n```\n> 장애물 없음. 3x3에서 오른쪽 2번, 아래 2번 → C(4,2) = 6가지\n\n**예시 3:**\n```\n입력:\n2\n0 1\n0 0\n\n출력:\n1\n```\n> (0,1)이 막혀서 아래→오른쪽 경로 1개만 가능",
  "starter_code": "n = int(input())\ngrid = []\nfor _ in range(n):\n    row = list(map(int, input().split()))\n    grid.append(row)\n\n# 파이보가 (0,0)에서 (n-1,n-1)까지 갈 수 있는 경로 수를 구하세요\n# 힌트: DP 테이블을 만들어보세요!\n",
  "test_cases": [
    {
      "input": "3\n0 0 0\n0 1 0\n0 0 0",
      "expected_output": "2",
      "description": "가운데 벽, 2가지 경로"
    },
    {
      "input": "3\n0 0 0\n0 0 0\n0 0 0",
      "expected_output": "6",
      "description": "장애물 없는 3x3"
    },
    {
      "input": "2\n0 1\n0 0",
      "expected_output": "1",
      "description": "2x2 하나 막힘"
    },
    {
      "input": "4\n0 0 0 0\n0 1 0 0\n0 0 0 1\n0 0 0 0",
      "expected_output": "4",
      "description": "4x4 장애물 2개"
    },
    {
      "input": "2\n0 0\n0 0",
      "expected_output": "2",
      "description": "2x2 장애물 없음"
    }
  ],
  "hints": [
    "각 칸에 도달하는 방법의 수를 저장하는 2차원 배열(DP 테이블)을 만들어보세요.",
    "첫 번째 행과 첫 번째 열은 특별해요. 벽을 만나면 그 이후는 모두 0이 됩니다.",
    "dp[i][j] = dp[i-1][j] + dp[i][j-1] (단, grid[i][j]가 벽이면 dp[i][j] = 0)"
  ],
  "expected_approaches": [
    {
      "tag": "동적 프로그래밍(DP)",
      "description": "2차원 DP 테이블로 각 칸의 경로 수를 누적 계산"
    },
    {
      "tag": "재귀 + 메모이제이션",
      "description": "재귀적으로 경로를 탐색하되, 이미 계산한 칸은 저장"
    },
    {
      "tag": "순수 재귀 (DFS)",
      "description": "모든 경로를 재귀적으로 탐색 (작은 격자에서만 가능)"
    }
  ],
  "explanation": "## 풀이 해설\n\n### 핵심 개념\n이 문제는 **동적 프로그래밍(DP)**의 대표적인 문제야! 핵심 아이디어는 간단해:\n- 어떤 칸 `(i, j)`에 도달하는 경로 수 = **위에서 내려오는 경로 수** + **왼쪽에서 오는 경로 수**\n- 즉, `dp[i][j] = dp[i-1][j] + dp[i][j-1]`\n- 단, 벽(`1`)인 칸은 `dp[i][j] = 0`!\n\n```mermaid\nflowchart TD\n    A[\"격자 입력\"] --> B[\"dp 테이블 생성 (모두 0)\"]\n    B --> C[\"dp[0][0] = 1 (시작점)\"]\n    C --> D[\"첫 행/첫 열 초기화\"]\n    D --> E[\"나머지 칸 채우기\"]\n    E --> F{\"grid[i][j] == 1?\"}\n    F -->|벽| G[\"dp[i][j] = 0\"]\n    F -->|통로| H[\"dp[i][j] = dp[i-1][j] + dp[i][j-1]\"]\n    G --> I[\"dp[n-1][n-1] 출력\"]\n    H --> I\n    style C fill:#fef3c7,stroke:#f59e0b,color:#78350f,stroke-width:2px\n    style H fill:#dcfce7,stroke:#22c55e,color:#14532d,stroke-width:2px\n```\n\n### 대표 풀이: 동적 프로그래밍(DP)\n```python\nn = int(input())\ngrid = []\nfor _ in range(n):\n    row = list(map(int, input().split()))\n    grid.append(row)\n\ndp = [[0] * n for _ in range(n)]\ndp[0][0] = 1\n\nfor i in range(n):\n    for j in range(n):\n        if i == 0 and j == 0:\n            continue\n        if grid[i][j] == 1:\n            dp[i][j] = 0\n        else:\n            up = dp[i-1][j] if i > 0 else 0\n            left = dp[i][j-1] if j > 0 else 0\n            dp[i][j] = up + left\n\nprint(dp[n-1][n-1])\n```\n\n**동작 확인:**\n- 테스트 1 (3x3, 가운데 벽): dp 테이블 → `[[1,1,1],[1,0,1],[1,1,2]]` → 2 ✓\n- 테스트 2 (3x3, 장애물 없음): dp 테이블 → `[[1,1,1],[1,2,3],[1,3,6]]` → 6 ✓\n- 테스트 3 (2x2, (0,1) 벽): dp 테이블 → `[[1,0],[1,1]]` → 1 ✓\n- 테스트 4 (4x4, 벽 2개): dp 테이블 마지막 → 4 ✓\n- 테스트 5 (2x2, 장애물 없음): dp 테이블 → `[[1,1],[1,2]]` → 2 ✓\n\n### DP 테이블이 채워지는 과정 (테스트 1)\n\n```\n격자:              dp 테이블:\n0 0 0              1 1 1\n0 1 0     →        1 0 1\n0 0 0              1 1 2\n\n(1,1)은 벽이라 0!\ndp[2][2] = dp[1][2] + dp[2][1] = 1 + 1 = 2\n```\n\n### 다른 풀이 방법\n\n**재귀 + 메모이제이션**\n위에서 아래로 채우는 대신, 도착점에서 거꾸로 재귀적으로 탐색하는 방법이야.\n```python\nimport sys\nsys.setrecursionlimit(10000)\n\nn = int(input())\ngrid = []\nfor _ in range(n):\n    row = list(map(int, input().split()))\n    grid.append(row)\n\nmemo = {}\ndef count_paths(i, j):\n    if i < 0 or j < 0:\n        return 0\n    if grid[i][j] == 1:\n        return 0\n    if i == 0 and j == 0:\n        return 1\n    if (i, j) in memo:\n        return memo[(i, j)]\n    memo[(i, j)] = count_paths(i-1, j) + count_paths(i, j-1)\n    return memo[(i, j)]\n\nprint(count_paths(n-1, n-1))\n```\n`memo` 딕셔너리에 이미 계산한 결과를 저장해서 중복 계산을 막아. 이게 **메모이제이션**이야!\n\n**순수 재귀 (DFS) - 작은 격자용**\n메모이제이션 없이 모든 경로를 직접 탐색해. 격자가 크면 매우 느려지지만 이해하기 쉬워!\n```python\nn = int(input())\ngrid = []\nfor _ in range(n):\n    row = list(map(int, input().split()))\n    grid.append(row)\n\ndef dfs(i, j):\n    if i == n-1 and j == n-1:\n        return 1\n    if i >= n or j >= n or grid[i][j] == 1:\n        return 0\n    return dfs(i+1, j) + dfs(i, j+1)\n\nprint(dfs(0, 0))\n```\n\n### 주의할 점\n- **첫 번째 행과 첫 번째 열은 특별해!** 한 방향으로만 갈 수 있어서 벽을 만나면 그 뒤는 전부 0이 돼. 예: 첫 행이 `[0, 0, 1, 0]`이면 dp는 `[1, 1, 0, 0]`이야.\n- `i > 0`, `j > 0` 체크를 안 하면 **인덱스 에러**가 나! 경계 조건 처리를 꼼꼼히 해야 해.\n- 시작점 `(0,0)`이나 도착점 `(n-1,n-1)`이 벽이면 답은 항상 0이야. (이 문제에서는 항상 0이라고 했지만, 방어 코드를 넣으면 더 안전해!)\n- DP 풀이의 시간 복잡도는 **O(N^2)**으로, 순수 재귀의 지수 시간보다 훨씬 빨라!"
}