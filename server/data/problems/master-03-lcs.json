{
  "id": "master-03-lcs",
  "title": "공통 부분 수열 찾기",
  "difficulty": 5,
  "category": "algorithm",
  "description": "## 공통 부분 수열 찾기\n\n두 명의 마법사가 각자 **마법 주문**을 외웠습니다. 두 주문에서 **공통으로 들어있는 가장 긴 부분 수열**을 찾으면, 그것이 바로 궁극의 마법이 됩니다!\n\n### 부분 수열(Subsequence)이란?\n\n원래 문자열에서 **순서를 유지하면서** 일부 문자를 골라낸 것입니다. 연속하지 않아도 됩니다!\n\n```\n\"ABCBDAB\"의 부분 수열 예시:\n  \"AB\"     ← A, B를 순서대로 골라냄 (O)\n  \"BCAB\"   ← B, C, A, B를 순서대로 골라냄 (O)\n  \"BA\"     ← B 다음에 A? 원래 순서에서 가능 (O, B는 인덱스1, A는 인덱스4)\n  \"DBCA\"   ← D 다음에 B? D(인덱스4) 이후에 B(인덱스6)... C? 순서 안 맞음 (X)\n```\n\n### LCS (Longest Common Subsequence)\n\n두 문자열의 **공통 부분 수열** 중 **가장 긴 것의 길이**를 구하세요.\n\n```\n문자열 1: \"ABCBDAB\"\n문자열 2: \"BDCAB\"\n\n공통 부분 수열들: \"B\", \"AB\", \"BCB\", \"BCAB\", ...\n가장 긴 공통 부분 수열: \"BCAB\" (길이 4)\n```\n\n### DP 테이블 개념\n\n```mermaid\nflowchart TD\n    A[두 문자열 비교] --> B{현재 글자가 같은가?}\n    B -->|같다| C[\"왼쪽 위 대각선 값 + 1\"]\n    B -->|다르다| D[\"왼쪽 값과 위쪽 값 중 큰 것\"]\n    C --> E[DP 테이블 다음 칸으로]\n    D --> E\n    E --> F{모든 칸을 채웠나?}\n    F -->|No| A\n    F -->|Yes| G[\"테이블 오른쪽 아래 값 = LCS 길이\"]\n```\n\n### DP 테이블 예시\n\n문자열 1: \"ABCB\", 문자열 2: \"BDC\"\n\n```\n      \"\"  B  D  C\n  \"\"   0  0  0  0\n  A    0  0  0  0\n  B    0  1  1  1\n  C    0  1  1  2\n  B    0  1  1  2\n```\n\n테이블의 마지막 값 **2**가 LCS의 길이입니다! (공통 부분 수열: \"BC\")\n\n### 입력\n- 첫째 줄: 문자열 1 (영문 대문자)\n- 둘째 줄: 문자열 2 (영문 대문자)\n- 각 문자열의 길이는 1 이상 100 이하\n\n### 출력\n- 가장 긴 공통 부분 수열의 길이 (정수)\n\n### 예시\n\n**예시 1:**\n```\n입력:\nABCBDAB\nBDCAB\n\n출력:\n4\n```\n> LCS는 \"BCAB\"으로 길이 4\n\n**예시 2:**\n```\n입력:\nABCD\nEFGH\n\n출력:\n0\n```\n> 공통 문자가 하나도 없으므로 LCS 길이는 0\n\n**예시 3:**\n```\n입력:\nAGGTAB\nGXTXAYB\n\n출력:\n4\n```\n> LCS는 \"GTAB\"으로 길이 4",
  "starter_code": "s1 = input()\ns2 = input()\n\n# 2차원 DP 테이블을 만들어보세요\n# dp[i][j] = s1의 처음 i글자와 s2의 처음 j글자의 LCS 길이\n# 글자가 같으면? 다르면? 점화식을 생각해보세요\n",
  "test_cases": [
    {
      "input": "ABCBDAB\nBDCAB",
      "expected_output": "4",
      "description": "기본 LCS 테스트 (BCAB, 길이 4)"
    },
    {
      "input": "ABCD\nEFGH",
      "expected_output": "0",
      "description": "공통 문자 없음"
    },
    {
      "input": "AAAA\nAA",
      "expected_output": "2",
      "description": "반복 문자 테스트"
    },
    {
      "input": "AGGTAB\nGXTXAYB",
      "expected_output": "4",
      "description": "GTAB, 길이 4"
    }
  ],
  "hints": [
    "2차원 리스트 dp를 만드세요. dp[i][j]는 s1[:i]와 s2[:j]의 LCS 길이입니다. dp = [[0]*(len(s2)+1) for _ in range(len(s1)+1)]",
    "점화식: s1[i-1] == s2[j-1]이면 dp[i][j] = dp[i-1][j-1] + 1, 아니면 dp[i][j] = max(dp[i-1][j], dp[i][j-1])",
    "최종 답은 dp[len(s1)][len(s2)]에 들어있습니다. 이중 for 루프로 테이블을 채워보세요!"
  ],
  "expected_approaches": [
    {
      "tag": "2D DP 테이블",
      "description": "(len(s1)+1) x (len(s2)+1) 크기의 2차원 테이블을 이중 for 루프로 채워서 해결. 가장 직관적인 풀이"
    },
    {
      "tag": "공간 최적화 1D DP",
      "description": "이전 행의 값만 필요하므로 1차원 배열 두 개(또는 하나)만 사용하여 메모리를 O(min(m,n))으로 줄이는 최적화"
    },
    {
      "tag": "재귀 + 메모이제이션",
      "description": "재귀적으로 LCS를 구하되, functools.lru_cache나 딕셔너리로 중복 계산을 방지하는 Top-down DP 방식"
    }
  ],
  "explanation": "## 풀이 해설\n\n### 핵심 개념\n이 문제는 **동적 프로그래밍(Dynamic Programming, DP)**의 대표적인 문제인 **LCS(Longest Common Subsequence)**예요! 두 문자열에서 순서를 유지하며 공통으로 나타나는 가장 긴 부분 수열의 길이를 구해요.\n\n핵심 점화식은 이거예요:\n- `s1[i-1] == s2[j-1]`이면: `dp[i][j] = dp[i-1][j-1] + 1` (대각선 + 1)\n- 다르면: `dp[i][j] = max(dp[i-1][j], dp[i][j-1])` (위쪽과 왼쪽 중 큰 값)\n\n```mermaid\nflowchart TD\n    A[\"dp 테이블 (m+1)x(n+1) 생성, 0으로 초기화\"] --> B[\"i=1부터 m까지 반복\"]\n    B --> C[\"j=1부터 n까지 반복\"]\n    C --> D{\"s1[i-1] == s2[j-1]?\"}\n    D -->|같다| E[\"dp[i][j] = dp[i-1][j-1] + 1\"]\n    D -->|다르다| F[\"dp[i][j] = max(dp[i-1][j], dp[i][j-1])\"]\n    E --> C\n    F --> C\n    C -->|j 끝| B\n    B -->|i 끝| G[\"dp[m][n] 출력\"]\n```\n\n### DP 테이블 시각화\n\n\"ABCB\"와 \"BDC\"의 예시:\n```\n       \"\"  B  D  C\n  \"\"    0  0  0  0\n   A    0  0  0  0\n   B    0  1  1  1\n   C    0  1  1  2\n   B    0  1  1  2\n```\n- (B,B) 만남 → 대각선(0)+1 = 1\n- (C,C) 만남 → 대각선(1)+1 = 2\n- 최종 답: dp[4][3] = 2 (공통 부분 수열 \"BC\")\n\n### 대표 풀이: 2D DP 테이블\n가장 직관적이고 이해하기 쉬운 방법이에요.\n```python\ns1 = input()\ns2 = input()\nm, n = len(s1), len(s2)\ndp = [[0] * (n + 1) for _ in range(m + 1)]\nfor i in range(1, m + 1):\n    for j in range(1, n + 1):\n        if s1[i-1] == s2[j-1]:\n            dp[i][j] = dp[i-1][j-1] + 1\n        else:\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1])\nprint(dp[m][n])\n```\n\n**동작 확인:**\n- \"ABCBDAB\" vs \"BDCAB\": dp[7][5] = 4 (LCS: \"BCAB\") ✓\n- \"ABCD\" vs \"EFGH\": dp[4][4] = 0 (공통 문자 없음) ✓\n- \"AAAA\" vs \"AA\": dp[4][2] = 2 ✓\n- \"AGGTAB\" vs \"GXTXAYB\": dp[6][7] = 4 (LCS: \"GTAB\") ✓\n\n### 다른 풀이 방법\n\n**공간 최적화 1D DP**\nDP 테이블에서 현재 행을 계산할 때 이전 행의 값만 필요하므로, 1차원 배열 두 개로 메모리를 절약할 수 있어요.\n```python\ns1 = input()\ns2 = input()\nm, n = len(s1), len(s2)\nif m < n:\n    s1, s2 = s2, s1\n    m, n = n, m\nprev = [0] * (n + 1)\nfor i in range(1, m + 1):\n    curr = [0] * (n + 1)\n    for j in range(1, n + 1):\n        if s1[i-1] == s2[j-1]:\n            curr[j] = prev[j-1] + 1\n        else:\n            curr[j] = max(prev[j], curr[j-1])\n    prev = curr\nprint(prev[n])\n```\n공간 복잡도가 O(m*n)에서 **O(min(m,n))**으로 줄어들어요!\n\n**재귀 + 메모이제이션 (Top-down DP)**\n`functools.lru_cache`를 사용해서 재귀적으로 풀 수도 있어요.\n```python\nfrom functools import lru_cache\n\ns1 = input()\ns2 = input()\n\n@lru_cache(maxsize=None)\ndef lcs(i, j):\n    if i == 0 or j == 0:\n        return 0\n    if s1[i-1] == s2[j-1]:\n        return lcs(i-1, j-1) + 1\n    return max(lcs(i-1, j), lcs(i, j-1))\n\nprint(lcs(len(s1), len(s2)))\n```\n`@lru_cache`가 이미 계산한 결과를 캐싱해서 중복 계산을 방지해요. Bottom-up DP와 동일한 결과를 내지만, 필요한 부분만 계산하는 장점이 있어요.\n\n### 시간 복잡도 분석\n- **시간 복잡도: O(m x n)** — m은 s1의 길이, n은 s2의 길이예요. 모든 (i,j) 쌍을 한 번씩 계산해요.\n- **공간 복잡도: O(m x n)** — 2D DP 테이블 기준이에요. 1D 최적화를 사용하면 O(min(m,n))으로 줄일 수 있어요.\n\n### 주의할 점\n- DP 테이블의 크기는 **(m+1) x (n+1)**이에요! 0번째 행과 열은 빈 문자열과의 비교를 위한 기저 조건(base case)으로, 모두 0이에요.\n- `s1[i-1]`과 `s2[j-1]`을 비교하는 거예요. dp 인덱스와 문자열 인덱스가 1씩 차이나는 점을 주의하세요!\n- **부분 수열(subsequence)**은 **부분 문자열(substring)**과 달라요. 부분 수열은 연속하지 않아도 되지만 순서는 유지해야 해요.\n- 이 문제는 LCS의 **길이**만 구하면 돼요. 실제 LCS **문자열**을 복원하려면 DP 테이블을 역추적(backtrack)해야 하는데, 그건 더 어려운 확장 문제예요.\n- LCS는 diff 도구, DNA 서열 비교, 버전 관리 시스템 등에서 실제로 사용되는 중요한 알고리즘이에요!"
}
