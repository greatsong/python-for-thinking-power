{
  "id": "solver-02-spiral",
  "title": "달팽이 배열",
  "difficulty": 4,
  "category": "algorithm",
  "description": "## 달팽이 배열\n\n마법의 달팽이가 NxN 격자판 위를 기어갑니다! 달팽이는 **왼쪽 위 모서리**에서 출발해서 **시계 방향**으로 빙글빙글 돌면서 지나간 칸에 1부터 차례대로 숫자를 남깁니다.\n\n달팽이가 모든 칸을 지나간 후의 격자판을 출력하세요!\n\n### 달팽이의 이동 경로\n\n```mermaid\nflowchart LR\n    A[오른쪽으로 →] --> B[아래로 ↓]\n    B --> C[왼쪽으로 ←]\n    C --> D[위로 ↑]\n    D --> A\n```\n\n달팽이는 **→ ↓ ← ↑** 순서로 방향을 바꾸면서, 벽이나 이미 지나간 칸을 만나면 다음 방향으로 회전합니다.\n\n### N=3 예시\n\n```\n→ → ↓\n↑   ↓\n↑ ← ←\n```\n\n결과:\n```\n1 2 3\n8 9 4\n7 6 5\n```\n\n### N=4 예시\n\n```\n 1  2  3  4\n12 13 14  5\n11 16 15  6\n10  9  8  7\n```\n\n### 입력\n- 정수 N (1 이상 10 이하)\n\n### 출력\n- N줄에 걸쳐 각 줄에 N개의 숫자를 공백으로 구분하여 출력\n\n### 예시\n\n**예시 1:**\n```\n입력:\n3\n\n출력:\n1 2 3\n8 9 4\n7 6 5\n```\n\n**예시 2:**\n```\n입력:\n2\n\n출력:\n1 2\n4 3\n```\n\n**예시 3:**\n```\n입력:\n4\n\n출력:\n1 2 3 4\n12 13 14 5\n11 16 15 6\n10 9 8 7\n```",
  "starter_code": "n = int(input())\n\n# NxN 배열을 만들고 달팽이 순서대로 채워보세요\n# 방향: 오른쪽 → 아래 → 왼쪽 → 위 (시계 방향)\n",
  "test_cases": [
    {
      "input": "2",
      "expected_output": "1 2\n4 3",
      "description": "2x2 배열"
    },
    {
      "input": "3",
      "expected_output": "1 2 3\n8 9 4\n7 6 5",
      "description": "3x3 배열"
    },
    {
      "input": "4",
      "expected_output": "1 2 3 4\n12 13 14 5\n11 16 15 6\n10 9 8 7",
      "description": "4x4 배열"
    }
  ],
  "hints": [
    "방향 벡터를 리스트로 만들어보세요: dx = [0, 1, 0, -1], dy = [1, 0, -1, 0] (오른쪽, 아래, 왼쪽, 위)",
    "다음 칸이 범위를 벗어나거나 이미 채워졌다면 방향을 바꿔야 해요. 방향 인덱스를 (현재+1) % 4로 바꿔보세요.",
    "NxN 크기의 2차원 리스트를 0으로 초기화하고, 현재 위치에 숫자를 채운 뒤 다음 위치로 이동하는 방식으로 시뮬레이션하세요."
  ],
  "expected_approaches": [
    {
      "tag": "방향 벡터 회전",
      "description": "dx, dy 방향 벡터를 사용하고, 벽이나 방문한 칸을 만나면 방향을 90도 회전시키며 1부터 N*N까지 채우기"
    },
    {
      "tag": "레이어별 채우기",
      "description": "바깥쪽 테두리부터 안쪽으로 한 겹씩 채워 나가는 방식. 각 레이어마다 위/오른쪽/아래/왼쪽을 순서대로 채움"
    },
    {
      "tag": "방문 배열 시뮬레이션",
      "description": "별도의 visited 배열로 방문 여부를 추적하며 달팽이 경로를 시뮬레이션"
    }
  ],
  "explanation": "## 풀이 해설\n\n### 핵심 개념\n이 문제는 **시뮬레이션**과 **방향 벡터**를 활용하는 문제예요! 달팽이처럼 시계 방향으로 빙글빙글 돌면서 2차원 배열을 채워야 해요. 핵심은 \"벽이나 이미 채운 칸을 만나면 방향을 바꾼다\"는 규칙이에요.\n\n```mermaid\nflowchart TD\n    A[\"NxN 배열을 0으로 초기화\"] --> B[\"위치=(0,0), 방향=오른쪽, 숫자=1\"]\n    B --> C[\"현재 위치에 숫자 채우기\"]\n    C --> D[\"다음 위치 계산\"]\n    D --> E{\"다음 위치가 유효한가?\\n(범위 안 & 아직 0)\"}\n    E -->|Yes| F[\"다음 위치로 이동\"]\n    E -->|No| G[\"방향 90도 회전\"]\n    G --> H[\"새 방향으로 다음 위치 계산\"]\n    H --> F\n    F --> I{\"숫자 == N*N?\"}\n    I -->|No| J[\"숫자 + 1\"] --> C\n    I -->|Yes| K[\"배열 출력\"]\n```\n\n### 대표 풀이: 방향 벡터 회전\n방향을 배열로 관리하고, 벽이나 방문한 칸을 만나면 방향을 바꾸는 방법이에요.\n```python\nn = int(input())\nmatrix = [[0] * n for _ in range(n)]\n# 오른쪽, 아래, 왼쪽, 위 순서\ndx = [0, 1, 0, -1]\ndy = [1, 0, -1, 0]\nd = 0  # 현재 방향 인덱스\nx, y = 0, 0\nfor num in range(1, n * n + 1):\n    matrix[x][y] = num\n    nx = x + dx[d]\n    ny = y + dy[d]\n    if 0 <= nx < n and 0 <= ny < n and matrix[nx][ny] == 0:\n        x, y = nx, ny\n    else:\n        d = (d + 1) % 4\n        x, y = x + dx[d], y + dy[d]\nfor row in matrix:\n    print(' '.join(map(str, row)))\n```\n\n**동작 확인:**\n- N=2: 1→(0,0), 2→(0,1), 방향전환↓, 3→(1,1), 방향전환←, 4→(1,0) → \"1 2\\n4 3\" ✓\n- N=3: \"1 2 3\\n8 9 4\\n7 6 5\" ✓\n- N=4: \"1 2 3 4\\n12 13 14 5\\n11 16 15 6\\n10 9 8 7\" ✓\n\n### 다른 풀이 방법\n\n**레이어별 채우기**\n바깥쪽 테두리부터 한 겹씩 안으로 들어가며 채우는 방법이에요.\n```python\nn = int(input())\nmatrix = [[0] * n for _ in range(n)]\nnum = 1\ntop, bottom, left, right = 0, n - 1, 0, n - 1\nwhile num <= n * n:\n    for j in range(left, right + 1):  # 위쪽 행: 왼→오\n        matrix[top][j] = num\n        num += 1\n    top += 1\n    for i in range(top, bottom + 1):  # 오른쪽 열: 위→아래\n        matrix[i][right] = num\n        num += 1\n    right -= 1\n    for j in range(right, left - 1, -1):  # 아래쪽 행: 오→왼\n        matrix[bottom][j] = num\n        num += 1\n    bottom -= 1\n    for i in range(bottom, top - 1, -1):  # 왼쪽 열: 아래→위\n        matrix[i][left] = num\n        num += 1\n    left += 1\nfor row in matrix:\n    print(' '.join(map(str, row)))\n```\n이 방법은 while 루프 한 번에 테두리 한 겹을 채워요. top, bottom, left, right 변수로 현재 채울 범위를 관리해요.\n\n### 주의할 점\n- 방향 벡터에서 `dx`는 행(세로), `dy`는 열(가로)이에요. 헷갈리기 쉬우니 주의하세요!\n- 방향 전환은 `(d + 1) % 4`로 해요. `%` 연산 덕분에 3(위) 다음에 다시 0(오른쪽)으로 돌아와요.\n- 배열이 0으로 초기화되어 있으므로, `matrix[nx][ny] == 0`으로 \"아직 채우지 않은 칸\"인지 확인할 수 있어요.\n- 시간 복잡도는 **O(N^2)**이에요. 모든 칸을 정확히 한 번씩 방문하니까요.\n- N=1인 경우에도 올바르게 동작하는지 확인하세요! (출력: \"1\")"
}
