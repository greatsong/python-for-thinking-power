{
  "id": "lv4-09-queue",
  "title": "í”„ë¦°í„° í ì‹œë®¬ë ˆì´ì…˜",
  "difficulty": 4,
  "category": "algorithm",
  "description": "## ğŸ–¨ï¸ ì¤‘ìš”ë„ ê¸°ë°˜ í”„ë¦°í„°!\n\ní”„ë¦°í„°ê°€ ë‹¤ìŒ ê·œì¹™ìœ¼ë¡œ ì¶œë ¥í•´ìš”:\n1. ëŒ€ê¸° íì—ì„œ ì²« ë²ˆì§¸ ë¬¸ì„œë¥¼ êº¼ëƒ„\n2. ëŒ€ê¸° íì— ë” ë†’ì€ ìš°ì„ ìˆœìœ„ ë¬¸ì„œê°€ ìˆìœ¼ë©´ â†’ ë‹¤ì‹œ ë§¨ ë’¤ë¡œ\n3. ì—†ìœ¼ë©´ â†’ ë°”ë¡œ ì¶œë ¥\n\níŠ¹ì • ë¬¸ì„œê°€ ëª‡ ë²ˆì§¸ë¡œ ì¶œë ¥ë˜ëŠ”ì§€ êµ¬í•´ìš”!\n\n```\nìš°ì„ ìˆœìœ„: [1, 1, 9, 1, 1, 1]\ní™•ì¸í•  ë¬¸ì„œ: 0ë²ˆ(ìš°ì„ ìˆœìœ„ 1)\n\nìˆœì„œ:\n[1,1,9,1,1,1] â†’ 9ê°€ ë” ë†’ì•„ì„œ 1ì„ ë’¤ë¡œ â†’ [1,9,1,1,1,1]\n[1,9,1,1,1,1] â†’ 9ê°€ ë” ë†’ì•„ì„œ 1ì„ ë’¤ë¡œ â†’ [9,1,1,1,1,1]\n[9,...] â†’ 9 ì¶œë ¥ (1ë²ˆì§¸)\n...\n```\n\n---\n\n## ë¬¸ì œ\n\në¬¸ì„œ ìˆ˜, í™•ì¸í•  ë¬¸ì„œ ìœ„ì¹˜, ìš°ì„ ìˆœìœ„ë¥¼ ì…ë ¥ë°›ì•„ í•´ë‹¹ ë¬¸ì„œê°€ ëª‡ ë²ˆì§¸ë¡œ ì¶œë ¥ë˜ëŠ”ì§€ ì¶œë ¥í•˜ì„¸ìš”.\n\n### ì…ë ¥\n- ì²«ì§¸ ì¤„: ë¬¸ì„œ ìˆ˜ n, í™•ì¸í•  ìœ„ì¹˜ m\n- ë‘˜ì§¸ ì¤„: ê° ë¬¸ì„œì˜ ìš°ì„ ìˆœìœ„\n\n### ì˜ˆì‹œ\n```\nì…ë ¥:\n6 0\n1 1 9 1 1 1\nì¶œë ¥: 5\n```",
  "starter_code": "n, m = map(int, input().split())\nprior = list(map(int, input().split()))\n\n# më²ˆ ë¬¸ì„œê°€ ëª‡ ë²ˆì§¸ë¡œ ì¶œë ¥ë˜ëŠ”ì§€ êµ¬í•˜ì„¸ìš”\n",
  "test_cases": [
    { "input": "6 0\n1 1 9 1 1 1", "expected_output": "5", "description": "0ë²ˆ ë¬¸ì„œëŠ” 5ë²ˆì§¸ ì¶œë ¥" },
    { "input": "1 0\n5", "expected_output": "1", "description": "ë¬¸ì„œ 1ê°œ â†’ 1ë²ˆì§¸" },
    { "input": "4 2\n1 2 3 2", "expected_output": "1", "description": "2ë²ˆ ë¬¸ì„œ(ìš°ì„ ìˆœìœ„ 3)ëŠ” 1ë²ˆì§¸ ì¶œë ¥" }
  ],
  "hints": [
    "from collections import dequeë¥¼ ì‚¬ìš©í•˜ë©´ íë¥¼ íš¨ìœ¨ì ìœ¼ë¡œ êµ¬í˜„í•´ìš”.",
    "dequeì— (ìš°ì„ ìˆœìœ„, ì›ë˜ ì¸ë±ìŠ¤) ìŒì„ ì €ì¥í•˜ì„¸ìš”.",
    "popleft()ë¡œ ì•ì—ì„œ êº¼ë‚´ê³ , append()ë¡œ ë’¤ì— ì¶”ê°€í•´ìš”."
  ],
  "expected_approaches": [
    { "tag": "deque ì‹œë®¬ë ˆì´ì…˜", "description": "(priority, index) ìŒì„ dequeë¡œ ê´€ë¦¬" },
    { "tag": "ë¦¬ìŠ¤íŠ¸ ì‹œë®¬ë ˆì´ì…˜", "description": "pop(0)ì™€ append()ë¡œ êµ¬í˜„ (ëŠë¦¬ì§€ë§Œ ê°€ëŠ¥)" }
  ],
  "explanation": "## í’€ì´ í•´ì„¤\n\n**í”„ë¦°í„° í ì‹œë®¬ë ˆì´ì…˜ íë¦„:**\n\n```mermaid\nflowchart TD\n    A[\"í ì•ì—ì„œ ë¬¸ì„œ êº¼ë‚´ê¸°\\npopleft\"] --> B{\"ëŒ€ê¸° íì— ë” ë†’ì€\\nìš°ì„ ìˆœìœ„ê°€ ìˆë‚˜?\"}\n    B -->|\"Yes\"| C[\"ë’¤ë¡œ ë‹¤ì‹œ ë„£ê¸°\\nappend\"]\n    C --> A\n    B -->|\"No\"| D[\"ì¶œë ¥! order += 1\"]\n    D --> E{\"ì°¾ëŠ” ë¬¸ì„œì¸ê°€?\"}\n    E -->|\"Yes\"| F[\"order ì¶œë ¥ í›„ ì¢…ë£Œ\"]\n    E -->|\"No\"| A\n    style F fill:#90EE90\n    style C fill:#FFD700\n    style D fill:#87CEEB\n```\n\n> ìš°ì„ ìˆœìœ„ê°€ ê°€ì¥ ë†’ì€ ë¬¸ì„œë§Œ ì¶œë ¥í•˜ê³ , ë‚˜ë¨¸ì§€ëŠ” ë’¤ë¡œ ë³´ë‚´ìš”!\n\n```python\nfrom collections import deque\n\nn, m = map(int, input().split())\nprior = list(map(int, input().split()))\n\n# (ìš°ì„ ìˆœìœ„, ì›ë˜ ì¸ë±ìŠ¤) ìŒìœ¼ë¡œ í êµ¬ì„±\nqueue = deque([(p, i) for i, p in enumerate(prior)])\norder = 0\n\nwhile queue:\n    p, idx = queue.popleft()  # ì•ì—ì„œ êº¼ë‚´ê¸°\n    # ëŒ€ê¸° ì¤‘ì— ë” ë†’ì€ ìš°ì„ ìˆœìœ„ê°€ ìˆë‚˜?\n    if any(q[0] > p for q in queue):\n        queue.append((p, idx))  # ë’¤ë¡œ ë³´ë‚´ê¸°\n    else:\n        order += 1\n        if idx == m:  # ìš°ë¦¬ê°€ ì°¾ëŠ” ë¬¸ì„œ!\n            print(order)\n            break\n```\n\n**deque(ë±)**: ì–‘ìª½ ëì—ì„œ O(1)ë¡œ ì‚½ì…/ì‚­ì œ ê°€ëŠ¥í•œ ìë£Œêµ¬ì¡°\n- `popleft()` â†’ ì•ì—ì„œ êº¼ë‚´ê¸° (íì˜ dequeue)\n- `append()` â†’ ë’¤ì— ë„£ê¸° (íì˜ enqueue)\n\në¦¬ìŠ¤íŠ¸ì˜ `pop(0)`ì€ O(n)ì´ì§€ë§Œ dequeëŠ” O(1)ì´ì—ìš”!"
}
