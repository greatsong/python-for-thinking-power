{
  "id": "challenger-02-word-frequency",
  "title": "인기 단어 TOP 3",
  "difficulty": 4,
  "category": "string",
  "description": "## 인기 단어 TOP 3\n\n문장에서 가장 많이 등장한 단어 TOP 3를 찾아봅시다!\n\n### 규칙\n\n1. **대소문자 구분 없음**: \"Hello\"와 \"hello\"는 같은 단어입니다.\n2. **구두점 제거**: 단어에 붙어있는 `.` `,` `!` `?`는 제거합니다.\n3. **빈도순 정렬**: 많이 등장한 순서대로 출력합니다.\n4. **동일 빈도 시**: 알파벳(사전) 순서가 빠른 단어를 먼저 출력합니다.\n5. 결과는 정확히 **3줄** 출력하며, 각 줄은 `단어 횟수` 형식입니다.\n\n### 처리 순서\n\n```mermaid\ngraph LR\n    A[\"원본 텍스트\"] --> B[\"소문자 변환\"]\n    B --> C[\"구두점 제거\"]\n    C --> D[\"단어 분리\"]\n    D --> E[\"빈도 카운트\"]\n    E --> F[\"정렬: 빈도 내림차순, 알파벳 오름차순\"]\n    F --> G[\"상위 3개 출력\"]\n```\n\n### 입력\n- 한 줄의 영어 텍스트 (단어가 3종류 이상 보장)\n\n### 출력\n- 3줄, 각 줄에 `단어 횟수` (공백 구분)\n\n### 예시\n\n**예시 1:**\n```\n입력: hello world hello python hello world\n출력:\nhello 3\nworld 2\npython 1\n```\n> hello(3회) > world(2회) > python(1회)\n\n**예시 2:**\n```\n입력: I love love love coding and I love Python\n출력:\nlove 4\ni 2\nand 1\n```\n> love(4회) > i(2회) > and, coding, python 모두 1회인데 알파벳순으로 and가 먼저\n\n**예시 3:**\n```\n입력: The cat sat on the mat. The cat is fat!\n출력:\nthe 3\ncat 2\nfat 1\n```\n> the(3회) > cat(2회) > fat, is, mat, on, sat 모두 1회인데 알파벳순으로 fat이 먼저",
  "starter_code": "text = input()\n\n# 1. 소문자로 변환하세요\n# 2. 구두점(. , ! ?)을 제거하세요\n# 3. 단어별 빈도를 세세요\n# 4. 빈도 내림차순, 같으면 알파벳순으로 정렬하세요\n# 5. 상위 3개를 출력하세요\n",
  "test_cases": [
    {
      "input": "hello world hello python hello world",
      "expected_output": "hello 3\nworld 2\npython 1",
      "description": "기본 테스트 — 빈도순 정렬"
    },
    {
      "input": "I love love love coding and I love Python",
      "expected_output": "love 4\ni 2\nand 1",
      "description": "대소문자 무시 + 동일 빈도 알파벳순"
    },
    {
      "input": "The cat sat on the mat. The cat is fat!",
      "expected_output": "the 3\ncat 2\nfat 1",
      "description": "구두점 제거 + 동일 빈도 알파벳순"
    }
  ],
  "hints": [
    "text.lower()로 소문자 변환 후, for c in '.,!?': text = text.replace(c, '')로 구두점을 제거하세요.",
    "딕셔너리로 빈도를 셀 수 있어요: words = text.split() 후 for문으로 각 단어를 카운트하세요.",
    "정렬할 때 sorted(items, key=lambda x: (-x[1], x[0]))을 쓰면 빈도 내림차순, 같으면 알파벳 오름차순으로 정렬돼요."
  ],
  "expected_approaches": [
    {
      "tag": "딕셔너리 직접 카운트",
      "description": "빈 딕셔너리를 만들고 for문으로 각 단어의 등장 횟수를 세는 방법"
    },
    {
      "tag": "collections.Counter",
      "description": "Counter 클래스를 사용해 단어 빈도를 자동으로 세고 most_common() 활용"
    },
    {
      "tag": "sorted + 커스텀 키",
      "description": "sorted()에 lambda 키를 사용해 빈도 내림차순, 알파벳 오름차순으로 정렬"
    }
  ],
  "explanation": "## 풀이 해설\n\n### 핵심 개념\n이 문제는 **문자열 처리**와 **딕셔너리(빈도 카운트)**, 그리고 **정렬**을 종합적으로 연습하는 문제예요! 텍스트를 정규화(소문자 변환, 구두점 제거)한 뒤 단어별 빈도를 세고, 정렬 기준을 두 개(빈도 내림차순 + 알파벳 오름차순) 적용하는 게 핵심이에요.\n\n```mermaid\ngraph LR\n    A[\"원본 텍스트\"] --> B[\"소문자 변환\\nlower()\"]\n    B --> C[\"구두점 제거\\nreplace()\"]\n    C --> D[\"단어 분리\\nsplit()\"]\n    D --> E[\"빈도 카운트\\n딕셔너리\"]\n    E --> F[\"정렬\\n-빈도, +알파벳\"]\n    F --> G[\"상위 3개 출력\"]\n    style E fill:#dbeafe,stroke:#3b82f6,color:#1e3a5f\n    style F fill:#dcfce7,stroke:#22c55e,color:#14532d\n```\n\n### 대표 풀이: 딕셔너리 직접 카운트 + sorted\n가장 기본적이면서 확실한 방법이에요.\n```python\ntext = input()\ntext = text.lower()\nfor c in '.,!?':\n    text = text.replace(c, '')\nwords = text.split()\n\nfreq = {}\nfor w in words:\n    freq[w] = freq.get(w, 0) + 1\n\nsorted_words = sorted(freq.items(), key=lambda x: (-x[1], x[0]))\nfor word, count in sorted_words[:3]:\n    print(f'{word} {count}')\n```\n처리 순서를 하나씩 살펴볼게요:\n1. `lower()`: \"Hello\"와 \"hello\"를 같은 단어로 취급하기 위해 소문자로 변환해요.\n2. `replace()`: 구두점 `.` `,` `!` `?`를 빈 문자열로 바꿔서 제거해요.\n3. `split()`: 공백 기준으로 단어를 나눠요.\n4. `freq.get(w, 0) + 1`: 딕셔너리에 단어가 없으면 0, 있으면 현재 값에 1을 더해요.\n5. `sorted(key=lambda x: (-x[1], x[0]))`: 빈도(`x[1]`)에 마이너스를 붙여 내림차순, 단어(`x[0]`)는 그대로 오름차순으로 정렬해요.\n\n### 다른 풀이 방법\n\n**collections.Counter 활용**\nCounter 클래스를 쓰면 빈도 세는 부분이 한 줄로 줄어들어요!\n```python\nfrom collections import Counter\n\ntext = input()\ntext = text.lower()\nfor c in '.,!?':\n    text = text.replace(c, '')\nwords = text.split()\n\nfreq = Counter(words)\nsorted_words = sorted(freq.items(), key=lambda x: (-x[1], x[0]))\nfor word, count in sorted_words[:3]:\n    print(f'{word} {count}')\n```\n`Counter(words)`는 리스트의 각 원소가 몇 번 등장하는지 자동으로 세줘요. 참고로 `Counter`의 `most_common(3)`도 있지만, 동일 빈도일 때 알파벳순 정렬을 보장하지 않으므로 `sorted()`를 직접 쓰는 게 안전해요.\n\n**리스트 컴프리헨션으로 간결하게**\n```python\ntext = input().lower()\nfor c in '.,!?':\n    text = text.replace(c, '')\nwords = text.split()\nfreq = {}\nfor w in words:\n    freq[w] = freq.get(w, 0) + 1\n[print(f'{w} {c}') for w, c in sorted(freq.items(), key=lambda x: (-x[1], x[0]))[:3]]\n```\n\n### 주의할 점\n- **대소문자 변환을 먼저** 해야 해요! \"I\"와 \"i\"가 같은 단어로 처리되어야 해요.\n- 구두점은 단어에 **붙어있는** 경우가 있어요. \"mat.\"에서 점을 제거해야 \"mat\"이 돼요.\n- `most_common()`은 동일 빈도일 때 순서가 보장되지 않으므로, 알파벳순 정렬이 필요하면 **직접 sorted()를 사용**하세요.\n- 정렬 키에서 `-x[1]`으로 빈도를 내림차순으로 만드는 트릭을 꼭 기억하세요! 숫자에 마이너스를 붙이면 정렬 방향이 뒤집혀요."
}