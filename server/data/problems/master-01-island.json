{
  "id": "master-01-island",
  "title": "보물섬 탐험",
  "difficulty": 5,
  "category": "algorithm",
  "description": "## 보물섬 탐험\n\n전설적인 탐험가인 여러분이 고대 지도를 발견했습니다! 지도에는 바다(0)와 땅(1)이 표시되어 있는데, 각각의 **독립된 섬**에 보물이 하나씩 숨겨져 있다고 합니다.\n\n보물을 모두 찾으려면 먼저 **섬이 총 몇 개인지** 알아야 합니다!\n\n### 섬이란?\n\n- **1(땅)**이 상하좌우로 연결되어 있으면 하나의 섬입니다\n- **대각선은 연결로 치지 않습니다**\n- 물(0)로 둘러싸여 떨어진 땅 덩어리는 각각 별개의 섬입니다\n\n```mermaid\nflowchart TD\n    A[지도에서 방문하지 않은 땅 1 찾기] --> B[그 칸에서 출발하여 연결된 모든 땅 탐색]\n    B --> C[탐색한 칸 모두 방문 처리]\n    C --> D[섬 개수 +1]\n    D --> E{방문하지 않은 땅이 남았나?}\n    E -->|Yes| A\n    E -->|No| F[총 섬 개수 출력]\n```\n\n### 예시 지도\n\n```\n1 1 0 0 1\n1 0 0 0 1\n0 0 0 0 0\n0 0 1 0 0\n```\n\n이 지도에는 **3개의 섬**이 있습니다:\n- 섬 1: 왼쪽 위 (1,1 / 1) 영역\n- 섬 2: 오른쪽 위 (1 / 1) 영역  \n- 섬 3: 가운데 아래 (1) 영역\n\n### 입력\n- 첫 줄: R C (행의 수, 열의 수, 공백으로 구분)\n- 다음 R줄: 각 줄에 C개의 0 또는 1 (공백으로 구분)\n\n### 출력\n- 섬의 개수 (정수 하나)\n\n### 예시\n\n**예시 1:**\n```\n입력:\n3 3\n1 1 0\n1 0 0\n0 0 1\n\n출력:\n2\n```\n> 왼쪽 위 땅 덩어리(3칸)와 오른쪽 아래 땅(1칸) → 섬 2개\n\n**예시 2:**\n```\n입력:\n4 5\n1 1 0 0 1\n1 0 0 1 1\n0 0 0 0 0\n1 0 1 0 1\n\n출력:\n5\n```\n> 5개의 분리된 땅 덩어리 → 섬 5개\n\n**예시 3:**\n```\n입력:\n2 2\n0 0\n0 0\n\n출력:\n0\n```\n> 땅이 없으면 섬도 없습니다!",
  "starter_code": "R, C = map(int, input().split())\ngrid = []\nfor _ in range(R):\n    row = list(map(int, input().split()))\n    grid.append(row)\n\n# 방문 여부를 추적할 방법을 정하세요\n# 격자를 탐색하며 새로운 땅(1)을 발견하면 연결된 모든 땅을 탐색하세요\n# BFS(너비 우선 탐색) 또는 DFS(깊이 우선 탐색)를 활용해보세요\n",
  "test_cases": [
    {
      "input": "3 3\n1 1 0\n1 0 0\n0 0 1",
      "expected_output": "2",
      "description": "기본 - 2개의 섬"
    },
    {
      "input": "4 5\n1 1 0 0 1\n1 0 0 1 1\n0 0 0 0 0\n1 0 1 0 1",
      "expected_output": "5",
      "description": "복잡한 지도 - 5개의 섬"
    },
    {
      "input": "2 2\n0 0\n0 0",
      "expected_output": "0",
      "description": "땅이 없는 경우"
    },
    {
      "input": "3 3\n1 1 1\n1 1 1\n1 1 1",
      "expected_output": "1",
      "description": "전부 땅 - 하나의 큰 섬"
    }
  ],
  "hints": [
    "BFS(너비 우선 탐색)를 사용해보세요. collections 모듈의 deque를 큐로 활용하면 편합니다.",
    "상하좌우 이동은 방향 벡터로 표현할 수 있어요: dx = [-1, 1, 0, 0], dy = [0, 0, -1, 1]",
    "격자를 이중 for 루프로 순회하면서, 방문하지 않은 1을 발견할 때마다 BFS/DFS로 연결된 모든 1을 방문 처리하고 섬 카운트를 1 증가시키세요."
  ],
  "expected_approaches": [
    {
      "tag": "BFS 플러드 필",
      "description": "deque를 사용한 너비 우선 탐색으로 연결된 땅을 모두 방문 처리하며 섬 개수를 셈"
    },
    {
      "tag": "DFS 재귀",
      "description": "재귀 함수로 깊이 우선 탐색을 수행하여 연결된 땅을 방문. 간결하지만 큰 격자에서는 재귀 깊이 제한 주의"
    },
    {
      "tag": "DFS 스택",
      "description": "명시적 스택(리스트)을 사용한 깊이 우선 탐색. 재귀 깊이 제한을 피하면서 DFS 수행 가능"
    }
  ]
}
