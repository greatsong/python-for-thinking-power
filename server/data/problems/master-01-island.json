{
  "id": "master-01-island",
  "title": "보물섬 탐험",
  "difficulty": 5,
  "category": "algorithm",
  "description": "## 보물섬 탐험\n\n전설적인 탐험가인 여러분이 고대 지도를 발견했습니다! 지도에는 바다(0)와 땅(1)이 표시되어 있는데, 각각의 **독립된 섬**에 보물이 하나씩 숨겨져 있다고 합니다.\n\n보물을 모두 찾으려면 먼저 **섬이 총 몇 개인지** 알아야 합니다!\n\n### 섬이란?\n\n- **1(땅)**이 상하좌우로 연결되어 있으면 하나의 섬입니다\n- **대각선은 연결로 치지 않습니다**\n- 물(0)로 둘러싸여 떨어진 땅 덩어리는 각각 별개의 섬입니다\n\n```mermaid\nflowchart TD\n    A[지도에서 방문하지 않은 땅 1 찾기] --> B[그 칸에서 출발하여 연결된 모든 땅 탐색]\n    B --> C[탐색한 칸 모두 방문 처리]\n    C --> D[섬 개수 +1]\n    D --> E{방문하지 않은 땅이 남았나?}\n    E -->|Yes| A\n    E -->|No| F[총 섬 개수 출력]\n```\n\n### 예시 지도\n\n```\n1 1 0 0 1\n1 0 0 0 1\n0 0 0 0 0\n0 0 1 0 0\n```\n\n이 지도에는 **3개의 섬**이 있습니다:\n- 섬 1: 왼쪽 위 (1,1 / 1) 영역\n- 섬 2: 오른쪽 위 (1 / 1) 영역  \n- 섬 3: 가운데 아래 (1) 영역\n\n### 입력\n- 첫 줄: R C (행의 수, 열의 수, 공백으로 구분)\n- 다음 R줄: 각 줄에 C개의 0 또는 1 (공백으로 구분)\n\n### 출력\n- 섬의 개수 (정수 하나)\n\n### 예시\n\n**예시 1:**\n```\n입력:\n3 3\n1 1 0\n1 0 0\n0 0 1\n\n출력:\n2\n```\n> 왼쪽 위 땅 덩어리(3칸)와 오른쪽 아래 땅(1칸) → 섬 2개\n\n**예시 2:**\n```\n입력:\n4 5\n1 1 0 0 1\n1 0 0 1 1\n0 0 0 0 0\n1 0 1 0 1\n\n출력:\n5\n```\n> 5개의 분리된 땅 덩어리 → 섬 5개\n\n**예시 3:**\n```\n입력:\n2 2\n0 0\n0 0\n\n출력:\n0\n```\n> 땅이 없으면 섬도 없습니다!",
  "starter_code": "R, C = map(int, input().split())\ngrid = []\nfor _ in range(R):\n    row = list(map(int, input().split()))\n    grid.append(row)\n\n# 방문 여부를 추적할 방법을 정하세요\n# 격자를 탐색하며 새로운 땅(1)을 발견하면 연결된 모든 땅을 탐색하세요\n# BFS(너비 우선 탐색) 또는 DFS(깊이 우선 탐색)를 활용해보세요\n",
  "test_cases": [
    {
      "input": "3 3\n1 1 0\n1 0 0\n0 0 1",
      "expected_output": "2",
      "description": "기본 - 2개의 섬"
    },
    {
      "input": "4 5\n1 1 0 0 1\n1 0 0 1 1\n0 0 0 0 0\n1 0 1 0 1",
      "expected_output": "5",
      "description": "복잡한 지도 - 5개의 섬"
    },
    {
      "input": "2 2\n0 0\n0 0",
      "expected_output": "0",
      "description": "땅이 없는 경우"
    },
    {
      "input": "3 3\n1 1 1\n1 1 1\n1 1 1",
      "expected_output": "1",
      "description": "전부 땅 - 하나의 큰 섬"
    }
  ],
  "hints": [
    "BFS(너비 우선 탐색)를 사용해보세요. collections 모듈의 deque를 큐로 활용하면 편합니다.",
    "상하좌우 이동은 방향 벡터로 표현할 수 있어요: dx = [-1, 1, 0, 0], dy = [0, 0, -1, 1]",
    "격자를 이중 for 루프로 순회하면서, 방문하지 않은 1을 발견할 때마다 BFS/DFS로 연결된 모든 1을 방문 처리하고 섬 카운트를 1 증가시키세요."
  ],
  "expected_approaches": [
    {
      "tag": "BFS 플러드 필",
      "description": "deque를 사용한 너비 우선 탐색으로 연결된 땅을 모두 방문 처리하며 섬 개수를 셈"
    },
    {
      "tag": "DFS 재귀",
      "description": "재귀 함수로 깊이 우선 탐색을 수행하여 연결된 땅을 방문. 간결하지만 큰 격자에서는 재귀 깊이 제한 주의"
    },
    {
      "tag": "DFS 스택",
      "description": "명시적 스택(리스트)을 사용한 깊이 우선 탐색. 재귀 깊이 제한을 피하면서 DFS 수행 가능"
    }
  ],
  "explanation": "## 풀이 해설\n\n### 핵심 개념\n이 문제는 그래프 탐색의 대표적인 유형인 **플러드 필(Flood Fill)** 문제예요! 2차원 격자에서 연결된 영역(섬)의 개수를 세는 거예요. **BFS(너비 우선 탐색)** 또는 **DFS(깊이 우선 탐색)**를 사용하면 돼요.\n\n```mermaid\nflowchart TD\n    A[\"격자의 모든 칸을 순회\"] --> B{\"현재 칸이 1(땅)이고\\n방문하지 않았나?\"}\n    B -->|Yes| C[\"섬 카운트 +1\"]\n    C --> D[\"BFS/DFS로 연결된\\n모든 땅을 방문 처리\"]\n    D --> A\n    B -->|No| A\n    A -->|순회 끝| E[\"섬 카운트 출력\"]\n\n    subgraph BFS 탐색\n        D --> F[\"큐에 현재 칸 넣기\"]\n        F --> G[\"큐에서 꺼내기\"]\n        G --> H[\"상하좌우 4방향 확인\"]\n        H --> I{\"범위 안 & 땅 & 미방문?\"}\n        I -->|Yes| J[\"방문 처리 후 큐에 넣기\"]\n        I -->|No| K[\"건너뛰기\"]\n        J --> G\n        K --> G\n    end\n```\n\n### 대표 풀이: BFS 플러드 필\n`collections.deque`를 사용한 BFS가 가장 안전하고 직관적인 방법이에요.\n```python\nfrom collections import deque\n\nR, C = map(int, input().split())\ngrid = []\nfor _ in range(R):\n    row = list(map(int, input().split()))\n    grid.append(row)\n\nvisited = [[False] * C for _ in range(R)]\ndx = [-1, 1, 0, 0]\ndy = [0, 0, -1, 1]\ncount = 0\n\nfor i in range(R):\n    for j in range(C):\n        if grid[i][j] == 1 and not visited[i][j]:\n            count += 1\n            queue = deque([(i, j)])\n            visited[i][j] = True\n            while queue:\n                x, y = queue.popleft()\n                for d in range(4):\n                    nx, ny = x + dx[d], y + dy[d]\n                    if 0 <= nx < R and 0 <= ny < C and grid[nx][ny] == 1 and not visited[nx][ny]:\n                        visited[nx][ny] = True\n                        queue.append((nx, ny))\n\nprint(count)\n```\n\n**동작 확인:**\n- 테스트 1 (3x3): 1,1,0/1,0,0/0,0,1 → (0,0)에서 BFS→{(0,0),(0,1),(1,0)} 방문, (2,2)에서 BFS→{(2,2)} 방문 → 2 ✓\n- 테스트 2 (4x5): 5개의 분리된 땅 덩어리 → 5 ✓\n- 테스트 3 (2x2 all 0): 땅 없음 → 0 ✓\n- 테스트 4 (3x3 all 1): 모두 연결 → 1 ✓\n\n### 다른 풀이 방법\n\n**DFS 재귀**\n재귀 호출로 연결된 땅을 탐색하는 방법이에요. 코드가 짧고 직관적이에요.\n```python\nimport sys\nsys.setrecursionlimit(10000)\n\nR, C = map(int, input().split())\ngrid = []\nfor _ in range(R):\n    row = list(map(int, input().split()))\n    grid.append(row)\n\ndef dfs(x, y):\n    if x < 0 or x >= R or y < 0 or y >= C:\n        return\n    if grid[x][y] == 0:\n        return\n    grid[x][y] = 0  # 방문 처리 (원본 격자 수정)\n    dfs(x-1, y)\n    dfs(x+1, y)\n    dfs(x, y-1)\n    dfs(x, y+1)\n\ncount = 0\nfor i in range(R):\n    for j in range(C):\n        if grid[i][j] == 1:\n            count += 1\n            dfs(i, j)\nprint(count)\n```\n이 방법은 별도의 `visited` 배열 대신 원본 격자의 1을 0으로 바꿔서 방문 처리해요. 메모리를 절약할 수 있지만 원본 데이터가 변경돼요.\n\n**DFS 스택 (반복문)**\n재귀 대신 명시적 스택을 사용하는 DFS예요. 재귀 깊이 제한이 걱정될 때 유용해요.\n```python\nR, C = map(int, input().split())\ngrid = []\nfor _ in range(R):\n    row = list(map(int, input().split()))\n    grid.append(row)\n\ncount = 0\nfor i in range(R):\n    for j in range(C):\n        if grid[i][j] == 1:\n            count += 1\n            stack = [(i, j)]\n            grid[i][j] = 0\n            while stack:\n                x, y = stack.pop()\n                for dx, dy in [(-1,0),(1,0),(0,-1),(0,1)]:\n                    nx, ny = x + dx, y + dy\n                    if 0 <= nx < R and 0 <= ny < C and grid[nx][ny] == 1:\n                        grid[nx][ny] = 0\n                        stack.append((nx, ny))\nprint(count)\n```\n\n### 시간 복잡도 분석\n- **시간 복잡도: O(R x C)** — 모든 칸을 최대 한 번씩 방문해요.\n- **공간 복잡도: O(R x C)** — visited 배열 또는 큐/스택의 최대 크기예요.\n\n### 주의할 점\n- **대각선은 연결이 아니에요!** 상하좌우 4방향만 확인하세요. dx, dy를 8방향으로 만들면 틀려요.\n- 재귀 DFS는 격자가 클 때 **RecursionError**가 발생할 수 있어요. `sys.setrecursionlimit()`으로 제한을 늘리거나 BFS/스택 DFS를 사용하세요.\n- BFS에서 큐에 넣을 때 **즉시 방문 처리**해야 해요. 꺼낼 때 하면 같은 칸이 여러 번 큐에 들어가서 비효율적이에요.\n- 이 문제는 코딩 테스트에서 매우 자주 출제되는 유형이에요. BFS/DFS를 확실히 익혀두세요!"
}
