{
  "id": "master-02-calculator",
  "title": "수식 계산기 만들기",
  "difficulty": 5,
  "category": "algorithm",
  "description": "## 수식 계산기 만들기\n\n여러분은 고대 유적에서 발견된 **마법의 계산기**를 복원해야 합니다! 이 계산기는 문자열로 된 수식을 입력받아 결과를 계산합니다.\n\n단, `eval()` 함수는 **봉인된 금지 마법**이라 사용할 수 없습니다! 직접 수식을 파싱하고 계산하는 알고리즘을 만들어야 합니다.\n\n### 지원하는 연산\n\n| 연산자 | 의미 | 우선순위 |\n|--------|------|----------|\n| `+`    | 덧셈 | 낮음 |\n| `-`    | 뺄셈 | 낮음 |\n| `*`    | 곱셈 | 높음 |\n| `//`   | 정수 나눗셈 | 높음 |\n| `( )`  | 괄호 | 최우선 |\n\n### 계산 규칙\n\n1. **괄호** 안의 식을 먼저 계산합니다\n2. **곱셈과 정수 나눗셈**을 먼저 계산합니다\n3. **덧셈과 뺄셈**을 나중에 계산합니다\n4. 같은 우선순위의 연산자는 **왼쪽에서 오른쪽** 순서로 계산합니다\n5. 모든 숫자는 음이 아닌 정수입니다\n6. 나눗셈은 정수 나눗셈(`//`)만 사용합니다\n\n```mermaid\nflowchart TD\n    A[수식 문자열 입력] --> B{괄호가 있나?}\n    B -->|Yes| C[가장 안쪽 괄호부터 계산]\n    B -->|No| D{*, // 가 있나?}\n    C --> B\n    D -->|Yes| E[왼쪽부터 *, // 계산]\n    D -->|No| F[왼쪽부터 +, - 계산]\n    E --> D\n    F --> G[최종 결과]\n```\n\n### 입력\n- 수식 문자열 (공백 없음, 길이 1 이상 100 이하)\n- 숫자는 0 이상의 정수, 연산자는 `+`, `-`, `*`, `//`, 괄호는 `(`, `)`\n\n### 출력\n- 계산 결과 (정수)\n\n### 예시\n\n**예시 1:**\n```\n입력:\n3+4*2-1\n\n출력:\n10\n```\n> 4*2=8 먼저, 그다음 3+8-1=10\n\n**예시 2:**\n```\n입력:\n(2+3)*(4-1)\n\n출력:\n15\n```\n> 괄호 먼저: (2+3)=5, (4-1)=3 → 5*3=15\n\n**예시 3:**\n```\n입력:\n((2+3)*2+1)*3\n\n출력:\n33\n```\n> 안쪽 괄호 (2+3)=5, 그다음 (5*2+1)=11, 마지막 11*3=33",
  "starter_code": "expr = input()\n\n# eval() 사용 금지!\n# 수식 문자열을 직접 파싱하여 계산하세요\n# 힌트: 스택을 활용하거나, 재귀적으로 접근해보세요\n",
  "test_cases": [
    {
      "input": "3+4*2-1",
      "expected_output": "10",
      "description": "연산자 우선순위 기본 테스트"
    },
    {
      "input": "(2+3)*(4-1)",
      "expected_output": "15",
      "description": "괄호 테스트"
    },
    {
      "input": "((2+3)*2+1)*3",
      "expected_output": "33",
      "description": "중첩 괄호 테스트"
    },
    {
      "input": "10+20*3",
      "expected_output": "70",
      "description": "두 자리 수 + 우선순위"
    },
    {
      "input": "100//3+2*5",
      "expected_output": "43",
      "description": "정수 나눗셈 테스트 (100//3=33, 2*5=10, 33+10=43)"
    }
  ],
  "hints": [
    "스택 두 개를 사용해보세요: 하나는 숫자용, 하나는 연산자용. 연산자의 우선순위에 따라 스택에서 꺼내 계산하는 타이밍이 달라집니다.",
    "괄호를 만나면? 여는 괄호 '('는 연산자 스택에 push, 닫는 괄호 ')'를 만나면 여는 괄호가 나올 때까지 연산자를 꺼내서 계산하세요.",
    "재귀 하강 파싱도 가능합니다: expression() → term()+/- term(), term() → factor()*// factor(), factor() → 숫자 또는 (expression()) 형태로 문법을 정의하세요."
  ],
  "expected_approaches": [
    {
      "tag": "스택 기반 파싱",
      "description": "숫자 스택과 연산자 스택을 사용하여, 우선순위가 높은 연산자를 먼저 처리하고 괄호를 스택으로 관리"
    },
    {
      "tag": "재귀 하강 파서",
      "description": "expression, term, factor 함수를 재귀적으로 호출하여 연산자 우선순위와 괄호를 자연스럽게 처리"
    },
    {
      "tag": "Shunting-Yard 알고리즘",
      "description": "다익스트라의 Shunting-Yard 알고리즘으로 중위 표기법을 후위 표기법으로 변환 후 계산"
    }
  ]
}
