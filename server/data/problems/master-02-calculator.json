{
  "id": "master-02-calculator",
  "title": "수식 계산기 만들기",
  "difficulty": 5,
  "category": "algorithm",
  "description": "## 수식 계산기 만들기\n\n여러분은 고대 유적에서 발견된 **마법의 계산기**를 복원해야 합니다! 이 계산기는 문자열로 된 수식을 입력받아 결과를 계산합니다.\n\n단, `eval()` 함수는 **봉인된 금지 마법**이라 사용할 수 없습니다! 직접 수식을 파싱하고 계산하는 알고리즘을 만들어야 합니다.\n\n### 지원하는 연산\n\n| 연산자 | 의미 | 우선순위 |\n|--------|------|----------|\n| `+`    | 덧셈 | 낮음 |\n| `-`    | 뺄셈 | 낮음 |\n| `*`    | 곱셈 | 높음 |\n| `//`   | 정수 나눗셈 | 높음 |\n| `( )`  | 괄호 | 최우선 |\n\n### 계산 규칙\n\n1. **괄호** 안의 식을 먼저 계산합니다\n2. **곱셈과 정수 나눗셈**을 먼저 계산합니다\n3. **덧셈과 뺄셈**을 나중에 계산합니다\n4. 같은 우선순위의 연산자는 **왼쪽에서 오른쪽** 순서로 계산합니다\n5. 모든 숫자는 음이 아닌 정수입니다\n6. 나눗셈은 정수 나눗셈(`//`)만 사용합니다\n\n```mermaid\nflowchart TD\n    A[수식 문자열 입력] --> B{괄호가 있나?}\n    B -->|Yes| C[가장 안쪽 괄호부터 계산]\n    B -->|No| D{*, // 가 있나?}\n    C --> B\n    D -->|Yes| E[왼쪽부터 *, // 계산]\n    D -->|No| F[왼쪽부터 +, - 계산]\n    E --> D\n    F --> G[최종 결과]\n```\n\n### 입력\n- 수식 문자열 (공백 없음, 길이 1 이상 100 이하)\n- 숫자는 0 이상의 정수, 연산자는 `+`, `-`, `*`, `//`, 괄호는 `(`, `)`\n\n### 출력\n- 계산 결과 (정수)\n\n### 예시\n\n**예시 1:**\n```\n입력:\n3+4*2-1\n\n출력:\n10\n```\n> 4*2=8 먼저, 그다음 3+8-1=10\n\n**예시 2:**\n```\n입력:\n(2+3)*(4-1)\n\n출력:\n15\n```\n> 괄호 먼저: (2+3)=5, (4-1)=3 → 5*3=15\n\n**예시 3:**\n```\n입력:\n((2+3)*2+1)*3\n\n출력:\n33\n```\n> 안쪽 괄호 (2+3)=5, 그다음 (5*2+1)=11, 마지막 11*3=33",
  "starter_code": "expr = input()\n\n# eval() 사용 금지!\n# 수식 문자열을 직접 파싱하여 계산하세요\n# 힌트: 스택을 활용하거나, 재귀적으로 접근해보세요\n",
  "test_cases": [
    {
      "input": "3+4*2-1",
      "expected_output": "10",
      "description": "연산자 우선순위 기본 테스트"
    },
    {
      "input": "(2+3)*(4-1)",
      "expected_output": "15",
      "description": "괄호 테스트"
    },
    {
      "input": "((2+3)*2+1)*3",
      "expected_output": "33",
      "description": "중첩 괄호 테스트"
    },
    {
      "input": "10+20*3",
      "expected_output": "70",
      "description": "두 자리 수 + 우선순위"
    },
    {
      "input": "100//3+2*5",
      "expected_output": "43",
      "description": "정수 나눗셈 테스트 (100//3=33, 2*5=10, 33+10=43)"
    }
  ],
  "hints": [
    "스택 두 개를 사용해보세요: 하나는 숫자용, 하나는 연산자용. 연산자의 우선순위에 따라 스택에서 꺼내 계산하는 타이밍이 달라집니다.",
    "괄호를 만나면? 여는 괄호 '('는 연산자 스택에 push, 닫는 괄호 ')'를 만나면 여는 괄호가 나올 때까지 연산자를 꺼내서 계산하세요.",
    "재귀 하강 파싱도 가능합니다: expression() → term()+/- term(), term() → factor()*// factor(), factor() → 숫자 또는 (expression()) 형태로 문법을 정의하세요."
  ],
  "expected_approaches": [
    {
      "tag": "스택 기반 파싱",
      "description": "숫자 스택과 연산자 스택을 사용하여, 우선순위가 높은 연산자를 먼저 처리하고 괄호를 스택으로 관리"
    },
    {
      "tag": "재귀 하강 파서",
      "description": "expression, term, factor 함수를 재귀적으로 호출하여 연산자 우선순위와 괄호를 자연스럽게 처리"
    },
    {
      "tag": "Shunting-Yard 알고리즘",
      "description": "다익스트라의 Shunting-Yard 알고리즘으로 중위 표기법을 후위 표기법으로 변환 후 계산"
    }
  ],
  "explanation": "## 풀이 해설\n\n### 핵심 개념\n이 문제는 **수식 파싱(Expression Parsing)** 문제예요! `eval()`을 쓰지 않고 직접 연산자 우선순위와 괄호를 처리하는 계산기를 만들어야 해요. 컴파일러 이론의 기초가 되는 중요한 알고리즘이에요.\n\n핵심 아이디어는 **문법 규칙을 함수로 표현**하는 거예요:\n- `expression`: +, - 를 처리 (낮은 우선순위)\n- `term`: *, // 를 처리 (높은 우선순위)\n- `factor`: 숫자 또는 괄호를 처리 (최우선)\n\n```mermaid\nflowchart TD\n    A[\"expression()\"] --> B[\"term() 호출\"]\n    B --> C{\"다음이 + 또는 - ?\"}\n    C -->|Yes| D[\"term() 호출 후 연산\"]\n    D --> C\n    C -->|No| E[\"결과 반환\"]\n\n    F[\"term()\"] --> G[\"factor() 호출\"]\n    G --> H{\"다음이 * 또는 // ?\"}\n    H -->|Yes| I[\"factor() 호출 후 연산\"]\n    I --> H\n    H -->|No| J[\"결과 반환\"]\n\n    K[\"factor()\"] --> L{\"다음이 ( ?\"}\n    L -->|Yes| M[\"( 건너뛰기\"]\n    M --> N[\"expression() 호출\"]\n    N --> O[\") 건너뛰기\"]\n    O --> P[\"결과 반환\"]\n    L -->|No| Q[\"숫자 읽기\"]\n    Q --> P\n```\n\n### 대표 풀이: 재귀 하강 파서 (Recursive Descent Parser)\n문법 규칙을 그대로 함수로 옮기는 가장 우아한 방법이에요.\n```python\nexpr = input()\npos = 0\n\ndef parse_expression():\n    global pos\n    result = parse_term()\n    while pos < len(expr) and expr[pos] in '+-':\n        op = expr[pos]\n        pos += 1\n        right = parse_term()\n        if op == '+':\n            result += right\n        else:\n            result -= right\n    return result\n\ndef parse_term():\n    global pos\n    result = parse_factor()\n    while pos < len(expr) and (expr[pos] == '*' or (pos + 1 < len(expr) and expr[pos:pos+2] == '//')):\n        if expr[pos:pos+2] == '//':\n            pos += 2\n            right = parse_factor()\n            result = result // right\n        else:\n            pos += 1\n            right = parse_factor()\n            result *= right\n    return result\n\ndef parse_factor():\n    global pos\n    if expr[pos] == '(':\n        pos += 1  # '(' 건너뛰기\n        result = parse_expression()\n        pos += 1  # ')' 건너뛰기\n        return result\n    else:\n        start = pos\n        while pos < len(expr) and expr[pos].isdigit():\n            pos += 1\n        return int(expr[start:pos])\n\nprint(parse_expression())\n```\n\n**동작 확인:**\n- \"3+4*2-1\": expression→term(3), +, term(4*2=8), -, term(1) → 3+8-1=10 ✓\n- \"(2+3)*(4-1)\": term→factor((2+3)=5) * factor((4-1)=3) → 15 ✓\n- \"((2+3)*2+1)*3\": factor(((2+3)*2+1))=11, *3 → 33 ✓\n- \"10+20*3\": 10 + term(20*3=60) → 70 ✓\n- \"100//3+2*5\": term(100//3=33) + term(2*5=10) → 43 ✓\n\n### 다른 풀이 방법\n\n**스택 기반 파싱**\n숫자 스택과 연산자 스택 두 개를 사용하는 방법이에요.\n```python\nexpr = input()\n\ndef precedence(op):\n    if op in ('+', '-'):\n        return 1\n    if op in ('*', '//'):\n        return 2\n    return 0\n\ndef apply_op(nums, op):\n    b = nums.pop()\n    a = nums.pop()\n    if op == '+': nums.append(a + b)\n    elif op == '-': nums.append(a - b)\n    elif op == '*': nums.append(a * b)\n    elif op == '//': nums.append(a // b)\n\nnums = []\nops = []\ni = 0\nwhile i < len(expr):\n    if expr[i].isdigit():\n        j = i\n        while j < len(expr) and expr[j].isdigit():\n            j += 1\n        nums.append(int(expr[i:j]))\n        i = j\n    elif expr[i] == '(':\n        ops.append('(')\n        i += 1\n    elif expr[i] == ')':\n        while ops[-1] != '(':\n            apply_op(nums, ops.pop())\n        ops.pop()  # '(' 제거\n        i += 1\n    else:\n        if expr[i:i+2] == '//':\n            op = '//'\n            i += 2\n        else:\n            op = expr[i]\n            i += 1\n        while ops and ops[-1] != '(' and precedence(ops[-1]) >= precedence(op):\n            apply_op(nums, ops.pop())\n        ops.append(op)\n\nwhile ops:\n    apply_op(nums, ops.pop())\nprint(nums[0])\n```\n이 방법은 다익스트라의 **Shunting-Yard 알고리즘**의 변형이에요. 연산자의 우선순위를 비교해서 스택에서 꺼내는 타이밍을 결정해요.\n\n### 시간 복잡도 분석\n- **시간 복잡도: O(n)** — 수식 문자열을 한 번 순회하면서 처리해요.\n- **공간 복잡도: O(n)** — 재귀 호출 스택 또는 명시적 스택의 크기예요.\n\n### 주의할 점\n- `//`는 두 글자짜리 연산자예요! `/`가 나왔을 때 다음 문자도 `/`인지 확인해야 해요.\n- 두 자리 이상의 숫자(10, 100 등)를 올바르게 파싱해야 해요. 숫자가 연속되는 동안 모두 읽어야 해요.\n- 재귀 하강 파서에서 `pos`는 전역 변수로 관리하는 것이 편해요. 각 함수가 호출될 때 현재 위치에서 시작해요.\n- 괄호 안의 식은 다시 `expression()`을 호출해서 처리해요. 이것이 재귀의 핵심이에요!\n- `eval()` 사용은 보안 취약점이 될 수 있어서 실무에서도 직접 파싱하는 것이 권장돼요."
}
