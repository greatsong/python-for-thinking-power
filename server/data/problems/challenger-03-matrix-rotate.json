{
  "id": "challenger-03-matrix-rotate",
  "title": "사진 돌리기 90도",
  "difficulty": 4,
  "category": "list",
  "description": "## 사진 돌리기 90도\n\n스마트폰으로 사진을 찍었는데 방향이 잘못됐어요! NxN 크기의 숫자 행렬을 **시계 방향으로 90도** 회전시켜 봅시다.\n\n### 회전 원리\n\n3x3 행렬을 예로 들어볼게요:\n\n```\n원본:        90도 회전 후:\n1 2 3        7 4 1\n4 5 6   -->  8 5 2\n7 8 9        9 6 3\n```\n\n### 좌표 변환 규칙\n\n원래 위치 `(r, c)`에 있는 값은 회전 후 `(c, N-1-r)` 위치로 이동합니다.\n\n```mermaid\ngraph TD\n    A[\"원본 행렬\"] --> B[\"전치 (행과 열 교환)\"]\n    B --> C[\"각 행 뒤집기\"]\n    C --> D[\"회전 완료!\"]\n    \n    E[\"원본:\"] --> E1[\"1 2 3\"]\n    E1 --> E2[\"4 5 6\"]\n    E2 --> E3[\"7 8 9\"]\n    \n    F[\"전치:\"] --> F1[\"1 4 7\"]\n    F1 --> F2[\"2 5 8\"]\n    F2 --> F3[\"3 6 9\"]\n    \n    G[\"행 뒤집기:\"] --> G1[\"7 4 1\"]\n    G1 --> G2[\"8 5 2\"]\n    G2 --> G3[\"9 6 3\"]\n    \n    style B fill:#dbeafe,stroke:#3b82f6,color:#1e3a5f\n    style C fill:#dcfce7,stroke:#22c55e,color:#14532d\n```\n\n### 입력\n- 첫 줄: 정수 N (행렬 크기)\n- 이후 N줄: 각 줄에 N개의 정수 (공백 구분)\n\n### 출력\n- 90도 회전된 행렬 (각 줄에 N개의 정수, 공백 구분)\n\n### 예시\n\n**예시 1 (2x2):**\n```\n입력:\n2\n1 2\n3 4\n\n출력:\n3 1\n4 2\n```\n\n**예시 2 (3x3):**\n```\n입력:\n3\n1 2 3\n4 5 6\n7 8 9\n\n출력:\n7 4 1\n8 5 2\n9 6 3\n```\n\n**예시 3 (4x4):**\n```\n입력:\n4\n1 2 3 4\n5 6 7 8\n9 10 11 12\n13 14 15 16\n\n출력:\n13 9 5 1\n14 10 6 2\n15 11 7 3\n16 12 8 4\n```",
  "starter_code": "n = int(input())\nmatrix = []\nfor i in range(n):\n    row = list(map(int, input().split()))\n    matrix.append(row)\n\n# 행렬을 시계 방향 90도 회전하세요\n",
  "test_cases": [
    {
      "input": "2\n1 2\n3 4",
      "expected_output": "3 1\n4 2",
      "description": "2x2 행렬 회전"
    },
    {
      "input": "3\n1 2 3\n4 5 6\n7 8 9",
      "expected_output": "7 4 1\n8 5 2\n9 6 3",
      "description": "3x3 행렬 회전"
    },
    {
      "input": "4\n1 2 3 4\n5 6 7 8\n9 10 11 12\n13 14 15 16",
      "expected_output": "13 9 5 1\n14 10 6 2\n15 11 7 3\n16 12 8 4",
      "description": "4x4 행렬 회전"
    }
  ],
  "hints": [
    "새로운 빈 행렬을 만들어 놓고, 원본의 (r, c)를 새 행렬의 (c, N-1-r)에 넣어보세요.",
    "더 간단한 방법: 먼저 전치(행과 열 교환)한 다음, 각 행을 뒤집으면(reverse) 90도 회전이 됩니다!",
    "파이썬스럽게: list(zip(*matrix))로 전치하고, 각 행을 reversed()로 뒤집으면 한 줄로도 가능해요."
  ],
  "expected_approaches": [
    {
      "tag": "zip + reversed",
      "description": "zip(*matrix)로 전치한 뒤 각 행을 reversed()로 뒤집어 시계 방향 90도 회전 구현"
    },
    {
      "tag": "인덱스 직접 교환",
      "description": "새 행렬을 만들고 result[c][N-1-r] = matrix[r][c] 공식으로 직접 값을 배치"
    },
    {
      "tag": "전치 + 행 뒤집기",
      "description": "먼저 행과 열을 교환(전치)한 다음 각 행을 reverse()하는 두 단계 접근"
    }
  ],
  "explanation": "## 풀이 해설\n\n### 핵심 개념\n이 문제는 **2차원 리스트(행렬)**를 다루는 능력을 키우는 문제예요! 시계 방향 90도 회전은 두 가지 방법으로 접근할 수 있어요:\n1. **좌표 변환 공식**: 원래 `(r, c)` 위치의 값이 `(c, N-1-r)`로 이동\n2. **전치 + 행 뒤집기**: 행과 열을 바꾼 뒤 각 행을 뒤집기\n\n```mermaid\ngraph LR\n    subgraph \"방법: 전치 + 행 뒤집기\"\n    A[\"원본\\n1 2 3\\n4 5 6\\n7 8 9\"] --> B[\"전치\\n1 4 7\\n2 5 8\\n3 6 9\"]\n    B --> C[\"각 행 뒤집기\\n7 4 1\\n8 5 2\\n9 6 3\"]\n    end\n    style B fill:#dbeafe,stroke:#3b82f6,color:#1e3a5f\n    style C fill:#dcfce7,stroke:#22c55e,color:#14532d\n```\n\n### 대표 풀이: zip + reversed (파이썬다운 풀이)\n파이썬의 `zip()`과 `reversed()`를 활용하면 아주 간결하게 풀 수 있어요!\n```python\nn = int(input())\nmatrix = []\nfor i in range(n):\n    row = list(map(int, input().split()))\n    matrix.append(row)\n\nrotated = [list(row[::-1]) for row in zip(*matrix)]\nfor row in rotated:\n    print(' '.join(map(str, row)))\n```\n핵심 한 줄을 분석해 볼게요:\n- `zip(*matrix)`: `*`로 행렬을 풀어서(unpack) zip에 전달하면 **전치(transpose)**가 돼요. 행과 열이 뒤바뀌어요.\n- `row[::-1]`: 각 행을 **역순**으로 뒤집어요.\n- 전치 + 각 행 뒤집기 = **시계 방향 90도 회전**이에요!\n\n3x3 예시로 따라가 볼게요:\n```\nzip(*[[1,2,3],[4,5,6],[7,8,9]])\n= zip([1,2,3], [4,5,6], [7,8,9])\n= [(1,4,7), (2,5,8), (3,6,9)]  ← 전치!\n\n각 행 뒤집기:\n[7,4,1], [8,5,2], [9,6,3]  ← 90도 회전 완료!\n```\n\n### 다른 풀이 방법\n\n**인덱스 직접 교환**\n새 행렬을 만들어 좌표 변환 공식을 직접 적용하는 방법이에요. 원리를 이해하기 가장 좋아요!\n```python\nn = int(input())\nmatrix = []\nfor i in range(n):\n    row = list(map(int, input().split()))\n    matrix.append(row)\n\nresult = [[0] * n for _ in range(n)]\nfor r in range(n):\n    for c in range(n):\n        result[c][n - 1 - r] = matrix[r][c]\n\nfor row in result:\n    print(' '.join(map(str, row)))\n```\n`result[c][n-1-r] = matrix[r][c]`가 핵심 공식이에요. 원래 r행 c열에 있던 값이 c행 (N-1-r)열로 이동해요.\n\n**전치 후 행 뒤집기 (명시적)**\n`zip`을 쓰지 않고 직접 전치를 구현하는 방법이에요.\n```python\nn = int(input())\nmatrix = []\nfor i in range(n):\n    row = list(map(int, input().split()))\n    matrix.append(row)\n\n# 전치\ntransposed = [[matrix[r][c] for r in range(n)] for c in range(n)]\n# 각 행 뒤집기\nfor row in transposed:\n    row.reverse()\n\nfor row in transposed:\n    print(' '.join(map(str, row)))\n```\n\n### 주의할 점\n- `zip()`은 **튜플**을 반환해요. 수정이 필요하면 `list()`로 변환해야 해요.\n- `zip(*matrix)`에서 `*`(언패킹)을 빼먹으면 전치가 안 돼요! `*`가 리스트를 개별 인자로 풀어주는 역할을 해요.\n- 출력할 때 숫자 사이에 **공백**을 넣어야 해요. `' '.join(map(str, row))`를 사용하세요.\n- 시계 방향 90도와 반시계 방향 90도를 혼동하지 마세요! 반시계 방향은 각 **열**을 뒤집은 뒤 전치하면 돼요."
}