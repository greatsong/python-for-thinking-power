{
  "id": "creative-03-music",
  "title": "음악 플레이리스트",
  "difficulty": 5,
  "category": "list",
  "description": "## 음악 플레이리스트\n\n여러분은 통학 버스에서 음악을 듣는 DJ입니다! 정확히 **K곡**을 골라서 총 재생 시간이 딱 **T분**이 되는 플레이리스트를 만들고 싶어요.\n\nN곡의 재생 시간 목록이 주어질 때, 정확히 K곡을 골라서 합이 T가 되는 조합이 **존재하는지** 판단하세요.\n\n### 핵심 아이디어\n\nN곡 중에서 K곡을 고르는 모든 조합을 확인해보면 됩니다. Python의 `itertools.combinations`를 쓰면 편리해요!\n\n```\n곡 목록: [3, 5, 7, 4, 6] (5곡)\nK=3, T=15\n\n가능한 3곡 조합 중:\n(3, 5, 7) → 합 15 ✓ → YES!\n```\n\n### 조합이란?\n\n5곡 중 3곡을 고르는 방법: C(5,3) = 10가지\n\n```mermaid\nflowchart TD\n    A[\"N곡의 재생 시간 목록\"] --> B[\"K곡 조합 생성\"]\n    B --> C{\"합 == T?\"}\n    C -->|하나라도 YES| D[\"YES 출력\"]\n    C -->|모두 NO| E[\"NO 출력\"]\n```\n\n### 입력\n- 첫 줄: N(곡 수), K(선택할 곡 수), T(목표 시간)\n- 둘째 줄: N개의 재생 시간 (분 단위, 공백 구분)\n\n### 출력\n- 조합이 존재하면 `YES`, 없으면 `NO`\n\n### 예시\n\n**예시 1:**\n```\n입력:\n5 3 15\n3 5 7 4 6\n\n출력:\nYES\n```\n> 3 + 5 + 7 = 15 ✓\n\n**예시 2:**\n```\n입력:\n4 2 10\n3 7 5 2\n\n출력:\nYES\n```\n> 3 + 7 = 10 ✓\n\n**예시 3:**\n```\n입력:\n4 2 11\n3 7 5 2\n\n출력:\nNO\n```\n> 어떤 2곡 조합도 합이 11이 되지 않음",
  "starter_code": "n, k, t = map(int, input().split())\nsongs = list(map(int, input().split()))\n\n# 정확히 k곡을 골라 합이 t가 되는 조합이 있는지 확인하세요\n# 힌트: from itertools import combinations\n",
  "test_cases": [
    {
      "input": "5 3 15\n3 5 7 4 6",
      "expected_output": "YES",
      "description": "3+5+7=15"
    },
    {
      "input": "4 2 10\n3 7 5 2",
      "expected_output": "YES",
      "description": "3+7=10"
    },
    {
      "input": "4 2 11\n3 7 5 2",
      "expected_output": "NO",
      "description": "합 11인 2곡 조합 없음"
    },
    {
      "input": "6 3 20\n8 5 3 10 7 2",
      "expected_output": "YES",
      "description": "8+5+7=20"
    },
    {
      "input": "3 3 10\n2 3 4",
      "expected_output": "NO",
      "description": "전부 골라도 합 9"
    }
  ],
  "hints": [
    "from itertools import combinations를 사용하면 N개 중 K개를 고르는 모든 조합을 쉽게 만들 수 있어요.",
    "각 조합의 합(sum)이 T와 같은지 비교하세요. 하나라도 같으면 바로 YES!",
    "itertools 없이도 할 수 있어요: 재귀 함수로 '이 곡을 포함할지/말지' 결정하며 탐색 (백트래킹)"
  ],
  "expected_approaches": [
    {
      "tag": "itertools.combinations",
      "description": "combinations(songs, k)로 모든 K곡 조합을 생성하고 합 확인"
    },
    {
      "tag": "DFS/백트래킹",
      "description": "재귀적으로 곡을 선택/비선택하며 목표 합에 도달하는지 탐색"
    },
    {
      "tag": "중첩 반복문 (K가 작을 때)",
      "description": "K가 2~3이면 이중/삼중 반복문으로 직접 조합 확인"
    }
  ],
  "explanation": "## 풀이 해설\n\n### 핵심 개념\n이 문제는 **조합(Combination)** 문제야! N곡 중에서 K곡을 뽑아 합이 T가 되는지 확인하면 돼. 파이썬의 `itertools.combinations`를 쓰면 정말 간단하게 풀 수 있어!\n\n조합이란? 순서 상관없이 K개를 뽑는 거야. 예를 들어 [3,5,7]에서 2개를 뽑으면: (3,5), (3,7), (5,7) 이렇게 3가지야.\n\n```mermaid\nflowchart TD\n    A[\"N곡의 재생 시간 입력\"] --> B[\"K곡 조합 생성\"]\n    B --> C[\"각 조합의 합 계산\"]\n    C --> D{\"합 == T?\"}\n    D -->|Yes| E[\"YES 출력하고 종료\"]\n    D -->|No| F{\"더 확인할 조합?\"}\n    F -->|Yes| C\n    F -->|No| G[\"NO 출력\"]\n    style E fill:#dcfce7,stroke:#22c55e,color:#14532d,stroke-width:2px\n    style G fill:#fee2e2,stroke:#ef4444,color:#7f1d1d,stroke-width:2px\n```\n\n### 대표 풀이: itertools.combinations\n```python\nfrom itertools import combinations\n\nn, k, t = map(int, input().split())\nsongs = list(map(int, input().split()))\n\nfor combo in combinations(songs, k):\n    if sum(combo) == t:\n        print(\"YES\")\n        break\nelse:\n    print(\"NO\")\n```\n\n`for-else` 구문이 포인트야! `break`가 한 번도 실행되지 않았을 때만 `else` 블록이 실행돼.\n\n**동작 확인:**\n- 테스트 1: [3,5,7,4,6]에서 3곡, 목표 15 → (3,5,7)=15 ✓ → YES ✓\n- 테스트 2: [3,7,5,2]에서 2곡, 목표 10 → (3,7)=10 ✓ → YES ✓\n- 테스트 3: [3,7,5,2]에서 2곡, 목표 11 → 모든 조합 확인, 없음 → NO ✓\n- 테스트 4: [8,5,3,10,7,2]에서 3곡, 목표 20 → (8,5,7)=20 ✓ → YES ✓\n- 테스트 5: [2,3,4]에서 3곡, 목표 10 → (2,3,4)=9 → NO ✓\n\n### 다른 풀이 방법\n\n**any() 함수로 한 줄 풀이**\n`any()`는 하나라도 True면 True를 반환해. 가장 파이썬다운 풀이야!\n```python\nfrom itertools import combinations\nn, k, t = map(int, input().split())\nsongs = list(map(int, input().split()))\nprint(\"YES\" if any(sum(c) == t for c in combinations(songs, k)) else \"NO\")\n```\n\n**DFS/백트래킹 (itertools 없이)**\n`itertools`를 안 쓰고 직접 재귀로 조합을 만드는 방법이야. 알고리즘 대회에서 자주 쓰이는 패턴이야!\n```python\nn, k, t = map(int, input().split())\nsongs = list(map(int, input().split()))\n\ndef dfs(start, count, total):\n    if count == k:\n        return total == t\n    if start >= n:\n        return False\n    for i in range(start, n):\n        if dfs(i + 1, count + 1, total + songs[i]):\n            return True\n    return False\n\nprint(\"YES\" if dfs(0, 0, 0) else \"NO\")\n```\n\n**중첩 반복문 (K=2일 때)**\nK가 작으면 반복문을 직접 중첩해서 풀 수 있어. K=2인 경우:\n```python\nn, k, t = map(int, input().split())\nsongs = list(map(int, input().split()))\nfound = False\nfor i in range(n):\n    for j in range(i+1, n):\n        if songs[i] + songs[j] == t:\n            found = True\n            break\n    if found:\n        break\nprint(\"YES\" if found else \"NO\")\n```\n\n### 주의할 점\n- `combinations`는 **중복 없이** 뽑아. (3,5)와 (5,3)은 같은 조합으로 한 번만 나와.\n- `for-else` 구문에서 `else`는 `break` 없이 루프가 **정상 종료**됐을 때 실행돼. `break`가 실행되면 `else`는 건너뛰어!\n- 하나라도 찾으면 바로 `YES`를 출력하고 끝내야 해. 계속 탐색하면 시간이 낭비돼.\n- K가 N보다 크면 조합이 아예 없어서 자동으로 NO가 나와. `combinations`가 빈 결과를 반환하거든."
}