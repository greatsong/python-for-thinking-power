{
  "id": "lv5-20-slidingWindow",
  "title": "슬라이딩 윈도우 최솟값",
  "difficulty": 5,
  "category": "algorithm",
  "description": "## 🪟 미끄러지는 창문! (슬라이딩 윈도우)\n\n배열에서 크기 k인 윈도우를 오른쪽으로 슬라이딩하며\n각 윈도우에서 **최솟값**을 구해요.\n\n```\n배열: [1, 3, -1, -3, 5, 3, 6, 7]\nk = 3\n\n[1, 3,-1] → -1\n   [3,-1,-3] → -3\n      [-1,-3, 5] → -3\n         [-3, 5, 3] → -3\n            [5, 3, 6] → 3\n               [3, 6, 7] → 3\n\n출력: -1 -3 -3 -3 3 3\n```\n\n### 단순 방법: O(nk)\n각 윈도우에서 min() → 느림!\n\n### Deque 최적화: O(n)\n단조 덱(monotonic deque)으로 최솟값을 O(1)에!\n- 덱: 양방향으로 push/pop 가능\n- 덱에는 현재 윈도우에서 유용한 인덱스만 유지\n\n---\n\n## 문제\n\nn개 숫자와 k를 입력받아 크기 k 윈도우의 최솟값들을 출력하세요.\n\n### 입력\n- 첫째 줄: n k\n- 둘째 줄: 숫자들\n\n### 예시\n```\n입력:\n8 3\n1 3 -1 -3 5 3 6 7\n출력: -1 -3 -3 -3 3 3\n```",
  "starter_code": "from collections import deque\n\nn, k = map(int, input().split())\narr = list(map(int, input().split()))\n\n# 크기 k 윈도우의 최솟값을 출력하세요\n",
  "test_cases": [
    { "input": "8 3\n1 3 -1 -3 5 3 6 7", "expected_output": "-1 -3 -3 -3 3 3", "description": "기본 슬라이딩 윈도우" },
    { "input": "4 1\n1 2 3 4", "expected_output": "1 2 3 4", "description": "k=1이면 자신" },
    { "input": "4 4\n4 3 2 1", "expected_output": "1", "description": "k=n이면 전체 min" }
  ],
  "hints": [
    "dq = deque()  # 인덱스를 저장, arr[dq[0]]이 현재 윈도우 최솟값",
    "새 원소: dq 뒤에서 현재 원소보다 크거나 같은 것 제거 후 추가",
    "범위 벗어남: dq[0]이 현재 윈도우 밖이면 popleft()"
  ],
  "expected_approaches": [
    { "tag": "단조 덱 O(n)", "description": "덱에 최솟값 후보 인덱스 유지, 앞에서 꺼내 최솟값, 뒤에서 더 큰 것 제거" },
    { "tag": "단순 O(nk)", "description": "각 윈도우 min() 계산" }
  ],
  "explanation": "## 풀이 해설\n\n### 단조 덱 슬라이딩 윈도우 흐름도\n\n```mermaid\nflowchart TD\n    A[\"i = 0 ~ n-1 순회\"] --> B{\"덱 뒤 원소 >=\\n현재 arr[i]?\"}\n    B -->|\"Yes\"| C[\"덱 뒤에서 제거\\npop — 더 큰 값은 쓸모없음\"]\n    C --> B\n    B -->|\"No\"| D[\"덱 뒤에 i 추가\"]\n    D --> E{\"덱 앞 인덱스가\\n윈도우 밖?\"}\n    E -->|\"Yes\"| F[\"덱 앞에서 제거\\npopleft\"]\n    E -->|\"No\"| G{\"i >= k-1?\\n윈도우 완성?\"}\n    F --> G\n    G -->|\"Yes\"| H[\"arr[dq[0]] = 현재 최솟값!\\n결과에 추가\"]\n    G -->|\"No\"| I[\"다음 i로\"]\n    H --> I\n    I --> A\n    style C fill:#FF6B6B\n    style H fill:#90EE90\n    style D fill:#87CEEB\n```\n\n- **파란 박스**: 새 원소를 덱에 추가\n- **빨간 박스**: 쓸모없는 큰 값 제거 (단조성 유지)\n- **초록 박스**: 덱 앞(dq[0])이 항상 현재 윈도우 최솟값!\n- 덱은 항상 오름차순 유지됨\n\n### 방법 1: 단순 O(nk)\n```python\nn, k = map(int, input().split())\narr = list(map(int, input().split()))\n\nresult = []\nfor i in range(n - k + 1):\n    result.append(min(arr[i:i+k]))\nprint(*result)\n```\n\n### 방법 2: 단조 덱 O(n)\n```python\nfrom collections import deque\n\nn, k = map(int, input().split())\narr = list(map(int, input().split()))\n\ndq = deque()  # 인덱스 저장\nresult = []\n\nfor i in range(n):\n    # 현재 원소보다 크거나 같은 건 뒤에서 제거 (쓸모없어짐)\n    while dq and arr[dq[-1]] >= arr[i]:\n        dq.pop()\n    dq.append(i)\n    \n    # 윈도우 밖으로 나간 것 앞에서 제거\n    if dq[0] < i - k + 1:\n        dq.popleft()\n    \n    # 윈도우가 완성되면 결과 추가\n    if i >= k - 1:\n        result.append(arr[dq[0]])  # 덱 앞 = 현재 윈도우 최솟값!\n\nprint(*result)\n```\n\n**단조 덱 아이디어**:\n\n덱에는 \"미래에도 최솟값이 될 수 있는\" 후보만 유지!\n\n새 원소 x가 들어올 때, 덱 뒤에 있는 것들 중 x보다 크면 제거.\n왜? 그것들은 x가 윈도우에 있는 한 절대 최솟값이 될 수 없으니까!\n\n→ 덱은 항상 오름차순 유지 → `dq[0]`이 항상 최솟값!"
}
