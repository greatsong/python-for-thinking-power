{
  "id": "solver-01-compress",
  "title": "문자열 압축기",
  "difficulty": 4,
  "category": "string",
  "description": "## 문자열 압축기\n\n여러분은 비밀 조직의 **데이터 압축 전문가**입니다! 조직에서 보내는 메시지가 너무 길어서 적에게 들킬 위험이 있어요. 여러분의 임무는 메시지를 **Run-Length Encoding(RLE)** 방식으로 압축하는 것입니다.\n\n### RLE 압축이란?\n\n연속으로 반복되는 같은 문자를 **문자 + 반복 횟수**로 바꾸는 방식입니다.\n\n```\n\"aaabbbccca\" → \"a3b3c3a1\"\n\"aabba\"      → \"a2b2a1\"\n```\n\n### 주의! 압축의 함정\n\n압축한 결과가 원본보다 **더 길어지면** 압축하는 의미가 없겠죠? 그런 경우에는 **원본 문자열을 그대로** 출력합니다.\n\n```\n\"abc\" → 압축하면 \"a1b1c1\" (길이 6) > 원본 (길이 3) → \"abc\" 출력!\n\"aab\" → 압축하면 \"a2b1\" (길이 4) > 원본 (길이 3) → \"aab\" 출력!\n```\n\n```mermaid\nflowchart TD\n    A[입력 문자열] --> B[연속 반복 문자 그룹 찾기]\n    B --> C[각 그룹을 문자+횟수로 변환]\n    C --> D{압축 결과가 더 짧은가?}\n    D -->|Yes| E[압축 결과 출력]\n    D -->|No| F[원본 그대로 출력]\n```\n\n### 입력\n- 소문자 알파벳으로만 이루어진 문자열 (길이 1 이상 1000 이하)\n\n### 출력\n- 압축된 문자열 또는 원본 문자열 (더 짧은 쪽)\n- 길이가 같으면 압축된 문자열을 출력\n\n### 예시\n\n**예시 1:**\n```\n입력:\naaabbbccca\n\n출력:\na3b3c3a1\n```\n> 연속 반복: a(3), b(3), c(3), a(1) → \"a3b3c3a1\" (길이 8) < 원본 (길이 10) → 압축!\n\n**예시 2:**\n```\n입력:\nabc\n\n출력:\nabc\n```\n> 압축하면 \"a1b1c1\" (길이 6) > 원본 (길이 3) → 원본 출력!\n\n**예시 3:**\n```\n입력:\naaaaaa\n\n출력:\na6\n```\n> 모두 같은 문자! \"a6\" (길이 2) < 원본 (길이 6) → 압축!",
  "starter_code": "s = input()\n\n# 연속 반복되는 문자를 세어서 압축하세요\n# 압축 결과가 원본보다 짧거나 같으면 압축 결과를, 아니면 원본을 출력하세요\n",
  "test_cases": [
    {
      "input": "aaabbbccca",
      "expected_output": "a3b3c3a1",
      "description": "기본 테스트 - 여러 문자 반복"
    },
    {
      "input": "abc",
      "expected_output": "abc",
      "description": "반복 없음 - 압축하면 더 길어지는 경우"
    },
    {
      "input": "aaaaaa",
      "expected_output": "a6",
      "description": "모두 같은 문자"
    },
    {
      "input": "a",
      "expected_output": "a",
      "description": "한 글자 - 압축하면 \"a1\"로 더 길어짐"
    },
    {
      "input": "aabbaabb",
      "expected_output": "a2b2a2b2",
      "description": "반복 패턴 - 압축 길이 = 원본 길이 (같으면 압축 출력)"
    }
  ],
  "hints": [
    "for 루프로 문자열을 순회하면서, 이전 문자와 같으면 카운트를 증가시키고, 다르면 결과에 추가하는 방식을 생각해보세요.",
    "마지막 문자 그룹을 처리하는 것을 잊지 마세요! 루프가 끝난 후에도 마지막 그룹을 결과에 추가해야 합니다.",
    "itertools.groupby를 사용하면 연속된 같은 문자를 쉽게 그룹화할 수 있어요: from itertools import groupby"
  ],
  "expected_approaches": [
    {
      "tag": "for 루프 카운팅",
      "description": "문자열을 순회하며 현재 문자와 이전 문자를 비교하고, 같으면 카운트 증가, 다르면 결과에 추가"
    },
    {
      "tag": "itertools.groupby 활용",
      "description": "groupby로 연속 동일 문자를 그룹화하고 각 그룹의 길이를 세서 압축 문자열 생성"
    },
    {
      "tag": "정규표현식 (re 모듈)",
      "description": "re.findall(r'(.)\\1*', s)로 연속 반복 패턴을 찾아 각 매치의 길이로 압축"
    }
  ],
  "explanation": "## 풀이 해설\n\n### 핵심 개념\n이 문제는 **Run-Length Encoding(RLE)** 압축 알고리즘을 구현하는 문제예요! 연속으로 반복되는 문자를 `문자+횟수` 형태로 변환하고, 압축 결과가 원본보다 길어지면 원본을 그대로 출력해야 해요.\n\n```mermaid\nflowchart TD\n    A[\"문자열 입력\"] --> B[\"첫 문자를 현재 문자로 설정, 카운트=1\"]\n    B --> C[\"다음 문자로 이동\"]\n    C --> D{\"이전 문자와 같은가?\"}\n    D -->|Yes| E[\"카운트 + 1\"]\n    D -->|No| F[\"결과에 이전문자+카운트 추가\"]\n    F --> G[\"현재 문자를 새 기준으로, 카운트=1\"]\n    E --> C\n    G --> C\n    C -->|끝| H[\"마지막 그룹 결과에 추가\"]\n    H --> I{\"압축 길이 <= 원본 길이?\"}\n    I -->|Yes| J[\"압축 결과 출력\"]\n    I -->|No| K[\"원본 출력\"]\n```\n\n### 대표 풀이: for 루프 카운팅\n문자열을 순회하면서 이전 문자와 비교하며 카운트를 관리하는 방법이에요.\n```python\ns = input()\nresult = \"\"\ncurrent = s[0]\ncount = 1\nfor i in range(1, len(s)):\n    if s[i] == current:\n        count += 1\n    else:\n        result += current + str(count)\n        current = s[i]\n        count = 1\nresult += current + str(count)\nprint(result if len(result) <= len(s) else s)\n```\n\n**동작 확인:**\n- \"aaabbbccca\" → a3b3c3a1 (길이 8 <= 10) → \"a3b3c3a1\" ✓\n- \"abc\" → a1b1c1 (길이 6 > 3) → \"abc\" ✓\n- \"aaaaaa\" → a6 (길이 2 <= 6) → \"a6\" ✓\n- \"a\" → a1 (길이 2 > 1) → \"a\" ✓\n- \"aabbaabb\" → a2b2a2b2 (길이 8 <= 8) → \"a2b2a2b2\" ✓\n\n### 다른 풀이 방법\n\n**itertools.groupby 활용**\n`groupby`는 연속된 같은 값을 그룹으로 묶어주는 강력한 도구예요!\n```python\nfrom itertools import groupby\n\ns = input()\nresult = \"\"\nfor char, group in groupby(s):\n    result += char + str(len(list(group)))\nprint(result if len(result) <= len(s) else s)\n```\n`groupby(s)`는 연속된 같은 문자를 하나의 그룹으로 묶어줘요. `list(group)`의 길이가 곧 반복 횟수예요.\n\n**정규표현식(re 모듈) 활용**\n정규식으로 연속 반복 패턴을 한 번에 찾을 수 있어요.\n```python\nimport re\n\ns = input()\nmatches = re.findall(r'(.)\\1*', s)\nresult = \"\".join(c + str(len(m)) for m in re.finditer(r'(.)\\1*', s) for c in [m.group()[0]])\n# 더 간단한 버전:\nresult = \"\"\nfor m in re.finditer(r'(.)\\1*', s):\n    result += m.group()[0] + str(len(m.group()))\nprint(result if len(result) <= len(s) else s)\n```\n`(.)\\1*` 패턴은 \"한 문자를 캡처하고, 그 문자가 0번 이상 반복되는 부분\"을 찾아줘요.\n\n### 주의할 점\n- 루프 종료 후 **마지막 그룹**을 결과에 추가하는 것을 잊지 마세요! 이것은 가장 흔한 실수예요.\n- 문제에서 \"길이가 같으면 압축된 문자열을 출력\"이라고 했으므로, 비교 조건은 `<=`이에요. (`<`가 아니에요!)\n- 한 글자 문자열(\"a\")도 제대로 처리되는지 확인하세요. 이 경우 압축하면 \"a1\"(길이 2)이 되어 원본이 더 짧아요.\n- 시간 복잡도는 **O(n)**이에요. 문자열을 한 번만 순회하면 되니까요."
}
