{
  "id": "creative-05-tetris",
  "title": "테트리스 점수 계산기",
  "difficulty": 5,
  "category": "algorithm",
  "description": "## 테트리스 점수 계산기\n\n테트리스 게임을 하고 있어요! 현재 보드 상태가 주어지면, **꽉 찬 줄**을 찾아 제거하고 위의 블록들을 아래로 떨어뜨려야 합니다.\n\n### 규칙\n1. 한 줄의 모든 칸이 `1`(블록 있음)이면 **꽉 찬 줄**입니다\n2. 꽉 찬 줄을 모두 제거합니다\n3. 남은 줄들은 아래로 떨어집니다 (중력!)\n4. 제거된 줄 수만큼 맨 위에 빈 줄(`0 0 0 ...`)이 추가됩니다\n\n```mermaid\nflowchart LR\n    A[\"원본 보드\"] --> B[\"꽉 찬 줄 찾기\"]\n    B --> C[\"꽉 찬 줄 제거\"]\n    C --> D[\"남은 줄 아래로 이동\"]\n    D --> E[\"위에 빈 줄 추가\"]\n    E --> F[\"결과 출력\"]\n```\n\n### 동작 예시\n\n```\n원본 보드 (4x5):       제거 후 (중력 적용):\n1 1 1 1 1  ← 꽉 참!    0 0 0 0 0  ← 빈 줄 추가\n0 1 0 1 0              0 0 0 0 0  ← 빈 줄 추가\n1 1 1 1 1  ← 꽉 참!    0 1 0 1 0  ← 아래로 이동\n0 0 1 1 0              0 0 1 1 0  ← 아래로 이동\n\n제거된 줄: 2줄\n```\n\n### 입력\n- 첫 줄: R(행 수) C(열 수)\n- 다음 R줄: 각 줄에 C개의 숫자 (0 또는 1, 공백 구분)\n\n### 출력\n- 첫 줄: 제거된 줄의 수\n- 다음 R줄: 제거 후 보드 상태 (각 줄의 숫자를 공백으로 구분)\n\n### 예시\n\n**예시 1:**\n```\n입력:\n4 5\n1 1 1 1 1\n0 1 0 1 0\n1 1 1 1 1\n0 0 1 1 0\n\n출력:\n2\n0 0 0 0 0\n0 0 0 0 0\n0 1 0 1 0\n0 0 1 1 0\n```\n> 1번째, 3번째 줄이 꽉 참 → 제거 → 위에 빈 줄 2개 추가\n\n**예시 2:**\n```\n입력:\n3 4\n1 1 1 1\n1 1 1 1\n1 0 1 0\n\n출력:\n2\n0 0 0 0\n0 0 0 0\n1 0 1 0\n```\n> 1번째, 2번째 줄 제거 → 빈 줄 2개 추가\n\n**예시 3:**\n```\n입력:\n3 3\n0 1 0\n1 0 1\n0 1 0\n\n출력:\n0\n0 1 0\n1 0 1\n0 1 0\n```\n> 꽉 찬 줄 없음 → 변화 없음",
  "starter_code": "r, c = map(int, input().split())\nboard = []\nfor _ in range(r):\n    row = list(map(int, input().split()))\n    board.append(row)\n\n# 1. 꽉 찬 줄(모든 칸이 1)을 찾아서 제거하세요\n# 2. 남은 줄들을 아래로 내리고, 위에 빈 줄을 추가하세요\n# 3. 제거된 줄 수와 새 보드를 출력하세요\n",
  "test_cases": [
    {
      "input": "4 5\n1 1 1 1 1\n0 1 0 1 0\n1 1 1 1 1\n0 0 1 1 0",
      "expected_output": "2\n0 0 0 0 0\n0 0 0 0 0\n0 1 0 1 0\n0 0 1 1 0",
      "description": "2줄 제거, 중력 적용"
    },
    {
      "input": "3 4\n1 1 1 1\n1 1 1 1\n1 0 1 0",
      "expected_output": "2\n0 0 0 0\n0 0 0 0\n1 0 1 0",
      "description": "연속 2줄 제거"
    },
    {
      "input": "3 3\n0 1 0\n1 0 1\n0 1 0",
      "expected_output": "0\n0 1 0\n1 0 1\n0 1 0",
      "description": "제거할 줄 없음"
    },
    {
      "input": "5 4\n1 0 1 0\n1 1 1 1\n0 1 1 0\n1 1 1 1\n1 0 0 1",
      "expected_output": "2\n0 0 0 0\n0 0 0 0\n1 0 1 0\n0 1 1 0\n1 0 0 1",
      "description": "중간 줄 2개 제거"
    }
  ],
  "hints": [
    "꽉 찬 줄은 all(cell == 1 for cell in row) 또는 sum(row) == C로 판별할 수 있어요.",
    "리스트 컴프리헨션으로 꽉 차지 않은 줄만 남기세요: remaining = [row for row in board if sum(row) != c]",
    "빈 줄 추가: 제거된 줄 수만큼 [[0]*c for _ in range(cleared)] 를 앞에 붙이면 됩니다."
  ],
  "expected_approaches": [
    { "tag": "리스트 필터링", "description": "꽉 차지 않은 줄만 필터링하고, 앞에 빈 줄 추가" },
    { "tag": "시뮬레이션", "description": "꽉 찬 줄을 찾아 삭제(pop/del)하고, 위에 빈 줄을 삽입" },
    { "tag": "새 보드 구성", "description": "새로운 빈 보드를 만들고, 남은 줄을 아래부터 채워넣기" }
  ],
  "explanation": "## 풀이 해설\n\n### 핵심 개념\n이 문제는 **리스트 필터링**과 **조건 판별**을 연습하는 문제야! 테트리스에서 꽉 찬 줄을 제거하는 로직을 구현해야 해.\n\n핵심 단계는 3가지야:\n1. 모든 칸이 1인 줄(꽉 찬 줄)을 **찾아서 제거**\n2. 남은 줄들은 **아래로 떨어짐** (중력)\n3. 위에 **빈 줄 추가** (제거된 줄 수만큼)\n\n```mermaid\nflowchart LR\n    A[\"원본 보드\"] --> B[\"꽉 찬 줄 필터링\"]  \n    B --> C[\"remaining = 꽉 안 찬 줄들\"]  \n    C --> D[\"cleared = R - len(remaining)\"]  \n    D --> E[\"빈 줄 cleared개 + remaining\"]\n    E --> F[\"결과 출력\"]\n    style B fill:#dbeafe,stroke:#3b82f6,color:#1e3a5f,stroke-width:2px\n    style E fill:#dcfce7,stroke:#22c55e,color:#14532d,stroke-width:2px\n```\n\n### 대표 풀이: 리스트 필터링\n가장 깔끔하고 파이썬다운 풀이야!\n```python\nr, c = map(int, input().split())\nboard = []\nfor _ in range(r):\n    row = list(map(int, input().split()))\n    board.append(row)\n\nremaining = [row for row in board if sum(row) != c]\ncleared = r - len(remaining)\nnew_board = [[0] * c for _ in range(cleared)] + remaining\n\nprint(cleared)\nfor row in new_board:\n    print(' '.join(map(str, row)))\n```\n\n**핵심 아이디어:** `sum(row) != c`이면 그 줄은 꽉 차지 않은 거야! 모든 칸이 1이면 합이 c(열 개수)와 같거든.\n\n**동작 확인:**\n- 테스트 1 (4x5): 1행(합5=꽉참), 3행(합5=꽉참) 제거 → remaining=[2행,4행], cleared=2 → 빈줄2개+remaining → `2\\n0 0 0 0 0\\n0 0 0 0 0\\n0 1 0 1 0\\n0 0 1 1 0` ✓\n- 테스트 2 (3x4): 1행(합4), 2행(합4) 제거 → remaining=[3행], cleared=2 → `2\\n0 0 0 0\\n0 0 0 0\\n1 0 1 0` ✓\n- 테스트 3 (3x3): 꽉 찬 줄 없음 → cleared=0 → 원본 그대로 → `0\\n0 1 0\\n1 0 1\\n0 1 0` ✓\n- 테스트 4 (5x4): 2행(합4), 4행(합4) 제거 → remaining=[1행,3행,5행], cleared=2 → `2\\n0 0 0 0\\n0 0 0 0\\n1 0 1 0\\n0 1 1 0\\n1 0 0 1` ✓\n\n### 다른 풀이 방법\n\n**시뮬레이션 (del + insert)**\n실제로 줄을 삭제하고 빈 줄을 삽입하는 방법이야.\n```python\nr, c = map(int, input().split())\nboard = []\nfor _ in range(r):\n    row = list(map(int, input().split()))\n    board.append(row)\n\ncleared = 0\ni = 0\nwhile i < len(board):\n    if all(cell == 1 for cell in board[i]):\n        del board[i]\n        cleared += 1\n    else:\n        i += 1\n\nfor _ in range(cleared):\n    board.insert(0, [0] * c)\n\nprint(cleared)\nfor row in board:\n    print(' '.join(map(str, row)))\n```\n`del`로 줄을 지우고, `insert(0, ...)`로 맨 위에 빈 줄을 넣어. 단, 삭제 후 인덱스가 바뀌니까 `while`문을 써야 해!\n\n**새 보드 구성 (아래부터 채우기)**\n빈 보드를 먼저 만들고, 남은 줄을 아래부터 채워넣는 방법이야.\n```python\nr, c = map(int, input().split())\nboard = []\nfor _ in range(r):\n    row = list(map(int, input().split()))\n    board.append(row)\n\nremaining = [row for row in board if not all(v == 1 for v in row)]\ncleared = r - len(remaining)\nnew_board = [[0] * c] * r\nfor i in range(len(remaining)):\n    new_board[cleared + i] = remaining[i]\n\nprint(cleared)\nfor row in new_board:\n    print(' '.join(map(str, row)))\n```\n\n### 주의할 점\n- **꽉 찬 줄 판별:** `sum(row) == c` 또는 `all(cell == 1 for cell in row)` 둘 다 가능해. `sum`이 더 간결해!\n- 리스트를 순회하면서 `del`로 삭제할 때는 **인덱스가 밀려**! `for i in range(r)`로 하면 안 되고, `while`문을 쓰거나 뒤에서부터 삭제해야 해.\n- 빈 줄은 `[[0]*c] * cleared`가 아니라 `[[0]*c for _ in range(cleared)]`로 만들어야 해! `*` 연산은 같은 리스트 객체를 공유하는 **얕은 복사** 문제가 있어.\n- 출력할 때 각 줄의 숫자를 **공백으로 구분**해야 해. `' '.join(map(str, row))`를 쓰면 돼."
}
