{
  "id": "lv5-09-segment",
  "title": "êµ¬ê°„ í•© ì¿¼ë¦¬ (ì„¸ê·¸ë¨¼íŠ¸ íŠ¸ë¦¬)",
  "difficulty": 5,
  "category": "data-structure",
  "description": "## ğŸ“Š ë¹ ë¥¸ êµ¬ê°„ í•©! (ì„¸ê·¸ë¨¼íŠ¸ íŠ¸ë¦¬)\n\nnê°œì˜ ìˆ«ì ë°°ì—´ì—ì„œ êµ¬ê°„ í•© ì¿¼ë¦¬ì™€ ê°’ ì—…ë°ì´íŠ¸ë¥¼ ë¹ ë¥´ê²Œ ì²˜ë¦¬í•´ìš”.\n\n```\në°°ì—´: [1, 3, 5, 7, 9, 11]\n\nì¿¼ë¦¬ 1: 1~3ë²ˆ í•© = 1+3+5 = 9\nì—…ë°ì´íŠ¸: 3ë²ˆì„ 6ìœ¼ë¡œ ë³€ê²½\nì¿¼ë¦¬ 2: 1~3ë²ˆ í•© = 1+3+6 = 10\n```\n\n### ì™œ ì„¸ê·¸ë¨¼íŠ¸ íŠ¸ë¦¬ì¸ê°€?\n\n| ë°©ë²• | ì¿¼ë¦¬ | ì—…ë°ì´íŠ¸ |\n|------|------|----------|\n| ë‹¨ìˆœ ë°°ì—´ | O(n) | O(1) |\n| ëˆ„ì  í•© ë°°ì—´ | O(1) | O(n) |\n| ì„¸ê·¸ë¨¼íŠ¸ íŠ¸ë¦¬ | O(log n) | O(log n) |\n\nì—…ë°ì´íŠ¸ê°€ ë§ìœ¼ë©´ ì„¸ê·¸ë¨¼íŠ¸ íŠ¸ë¦¬ê°€ ìµœì !\n\n---\n\n## ë¬¸ì œ\n\nnê°œì˜ ìˆ«ìì™€ ì¿¼ë¦¬ë¥¼ ì²˜ë¦¬í•˜ì„¸ìš”.\n- `Q l r`: l~r êµ¬ê°„ì˜ í•© ì¶œë ¥ (1-indexed)\n- `U i v`: ië²ˆì§¸ ê°’ì„ vë¡œ ì—…ë°ì´íŠ¸\n\n### ì…ë ¥\n- ì²«ì§¸ ì¤„: n\n- ë‘˜ì§¸ ì¤„: ë°°ì—´ ê°’ë“¤\n- ì…‹ì§¸ ì¤„: ì¿¼ë¦¬ ìˆ˜ q\n- ì´í›„ qì¤„: ì¿¼ë¦¬\n\n### ì˜ˆì‹œ\n```\nì…ë ¥:\n6\n1 3 5 7 9 11\n3\nQ 1 3\nU 3 6\nQ 1 3\nì¶œë ¥:\n9\n10\n```",
  "starter_code": "n = int(input())\narr = list(map(int, input().split()))\nq = int(input())\n\n# ì„¸ê·¸ë¨¼íŠ¸ íŠ¸ë¦¬ë¥¼ êµ¬í˜„í•˜ê³  ì¿¼ë¦¬ë¥¼ ì²˜ë¦¬í•˜ì„¸ìš”\n",
  "test_cases": [
    { "input": "6\n1 3 5 7 9 11\n3\nQ 1 3\nU 3 6\nQ 1 3", "expected_output": "9\n10", "description": "ê¸°ë³¸ ì¿¼ë¦¬+ì—…ë°ì´íŠ¸" },
    { "input": "4\n1 2 3 4\n2\nQ 1 4\nQ 2 3", "expected_output": "10\n5", "description": "ì „ì²´ í•©ê³¼ ë¶€ë¶„ í•©" }
  ],
  "hints": [
    "tree = [0] * (4*n) ìœ¼ë¡œ ì„¸ê·¸ë¨¼íŠ¸ íŠ¸ë¦¬ ë°°ì—´ ì´ˆê¸°í™”",
    "def build(node, start, end): if start==end: tree[node]=arr[start-1]",
    "def query(node, start, end, l, r): ë²”ìœ„ ì²´í¬ í›„ í•© ë°˜í™˜",
    "def update(node, start, end, idx, val): ì¬ê·€ë¡œ ì•„ë˜ ë‚´ë ¤ê°€ ê°’ ë³€ê²½"
  ],
  "expected_approaches": [
    { "tag": "ì„¸ê·¸ë¨¼íŠ¸ íŠ¸ë¦¬ (ë°°ì—´ ê¸°ë°˜)", "description": "4*n í¬ê¸° ë°°ì—´ë¡œ íŠ¸ë¦¬ êµ¬ì„±, ì¬ê·€ë¡œ build/query/update ëª¨ë‘ O(log n)" },
    { "tag": "íœìœ… íŠ¸ë¦¬ (BIT)", "description": "ë¹„íŠ¸ ì—°ì‚°ìœ¼ë¡œ êµ¬ê°„ í•©ê³¼ ì—…ë°ì´íŠ¸ë¥¼ O(log n)ì— ì²˜ë¦¬ â€” êµ¬í˜„ì´ ë” ê°„ê²°" }
  ],
  "explanation": "## í’€ì´ í•´ì„¤\n\n### ì„¸ê·¸ë¨¼íŠ¸ íŠ¸ë¦¬ ì—°ì‚° íë¦„ë„\n\n```mermaid\nflowchart TD\n    subgraph BUILD[\"Build íŠ¸ë¦¬ êµ¬ì¶•\"]\n        B1[\"build(node, start, end)\"] --> B2{\"start == end?\"}\n        B2 -->|\"Yes\"| B3[\"ë¦¬í”„ ë…¸ë“œ\\ntree[node] = arr[start]\"]\n        B2 -->|\"No\"| B4[\"mid = (start+end)/2\"]\n        B4 --> B5[\"ì™¼ìª½ ìì‹ build\"]\n        B4 --> B6[\"ì˜¤ë¥¸ìª½ ìì‹ build\"]\n        B5 --> B7[\"tree[node] = ì™¼ìª½ + ì˜¤ë¥¸ìª½\"]\n        B6 --> B7\n    end\n    subgraph QUERY[\"Query êµ¬ê°„ í•© ì¡°íšŒ\"]\n        Q1{\"êµ¬ê°„ì´ ë²”ìœ„ ë°–?\"} -->|\"Yes\"| Q2[\"return 0\"]\n        Q1 -->|\"No\"| Q3{\"êµ¬ê°„ì— ì™„ì „ í¬í•¨?\"}\n        Q3 -->|\"Yes\"| Q4[\"return tree[node]\"]\n        Q3 -->|\"No\"| Q5[\"ì™¼ìª½ query + ì˜¤ë¥¸ìª½ query\"]\n    end\n    subgraph UPDATE[\"Update ê°’ ë³€ê²½\"]\n        U1[\"update(node, idx, val)\"] --> U2{\"ë¦¬í”„ ë„ë‹¬?\"}\n        U2 -->|\"Yes\"| U3[\"tree[node] = val\"]\n        U2 -->|\"No\"| U4[\"í•´ë‹¹ ìì‹ìœ¼ë¡œ ì¬ê·€\"]\n        U4 --> U5[\"tree[node] ì¬ê³„ì‚°\\n(ì™¼ìª½ + ì˜¤ë¥¸ìª½)\"]\n    end\n    style B3 fill:#90EE90\n    style Q4 fill:#87CEEB\n    style U3 fill:#FFD700\n```\n\n- **Build**: ë¶„í•  ì •ë³µìœ¼ë¡œ íŠ¸ë¦¬ êµ¬ì¶• (ë¦¬í”„ â†’ ë£¨íŠ¸)\n- **Query**: êµ¬ê°„ì´ í¬í•¨ë˜ë©´ ì¦‰ì‹œ ë°˜í™˜, ì•„ë‹ˆë©´ ì¢Œìš° ë¶„í• \n- **Update**: ë¦¬í”„ê¹Œì§€ ë‚´ë ¤ê°€ ê°’ ë³€ê²½ í›„ ë¶€ëª¨ë¡œ ì „íŒŒ\n\n```python\nn = int(input())\narr = list(map(int, input().split()))\ntree = [0] * (4 * n)\n\ndef build(node, start, end):\n    if start == end:\n        tree[node] = arr[start - 1]\n    else:\n        mid = (start + end) // 2\n        build(2*node, start, mid)\n        build(2*node+1, mid+1, end)\n        tree[node] = tree[2*node] + tree[2*node+1]\n\ndef query(node, start, end, l, r):\n    if r < start or end < l:  # ë²”ìœ„ ë°–\n        return 0\n    if l <= start and end <= r:  # ì™„ì „íˆ í¬í•¨\n        return tree[node]\n    mid = (start + end) // 2\n    return query(2*node, start, mid, l, r) + query(2*node+1, mid+1, end, l, r)\n\ndef update(node, start, end, idx, val):\n    if start == end:\n        tree[node] = val\n    else:\n        mid = (start + end) // 2\n        if idx <= mid:\n            update(2*node, start, mid, idx, val)\n        else:\n            update(2*node+1, mid+1, end, idx, val)\n        tree[node] = tree[2*node] + tree[2*node+1]\n\nbuild(1, 1, n)\n\nq = int(input())\nfor _ in range(q):\n    parts = input().split()\n    if parts[0] == 'Q':\n        l, r = int(parts[1]), int(parts[2])\n        print(query(1, 1, n, l, r))\n    else:  # U\n        i, v = int(parts[1]), int(parts[2])\n        update(1, 1, n, i, v)\n```\n\n**ì„¸ê·¸ë¨¼íŠ¸ íŠ¸ë¦¬ êµ¬ì¡°**:\n```\n[1,3,5,7]\nâ†’ ë£¨íŠ¸: 1+3+5+7=16\nâ†’ ì™¼ìª½: 1+3=4, ì˜¤ë¥¸ìª½: 5+7=12\nâ†’ ë¦¬í”„: 1, 3, 5, 7\n```\n\nìì‹ ë…¸ë“œ: `2*node`, `2*node+1`\në¶€ëª¨ ë…¸ë“œ: `node//2`\n\n**ì¿¼ë¦¬ ìµœì í™”**: êµ¬ê°„ì´ ë…¸ë“œ êµ¬ê°„ì— ì™„ì „íˆ í¬í•¨ë˜ë©´ ì¦‰ì‹œ ë°˜í™˜ â†’ O(log n)"
}
