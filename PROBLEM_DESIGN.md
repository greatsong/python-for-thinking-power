# 문제 출제 가이드라인

> **"사고력을 위한 파이썬"** 플랫폼의 문제를 설계하는 교사 및 출제자를 위한 실무 지침서입니다.

---

## 1. 출제 철학 — "같은 문제, 다른 생각"

### 핵심 원리

이 플랫폼의 교육 목표는 **파이썬 문법 암기가 아니라, 코드로 생각하는 힘을 기르는 것**입니다.

좋은 문제란 **정답이 하나인 문제가 아니라, 여러 사고 경로를 허용하는 문제**입니다. 학생 A와 학생 B가 같은 문제를 풀었을 때, 둘 다 정답이지만 전혀 다른 방식으로 접근했다면 — 그 차이를 비교하고 토론하는 과정에서 진정한 사고력이 자랍니다.

```
[문제] 1부터 100까지 홀수의 합을 구하세요

학생A: for + if문         → 2500 (완전 탐색)
학생B: range(1, 101, 2)   → 2500 (도구 활용)
학생C: 수학공식 50 * 50   → 2500 (수학적 사고)
학생D: while + 누적        → 2500 (절차적 사고)

→ 4명 모두 정답. 하지만 "생각의 경로"가 다르다.
→ 이 비교 과정에서 사고력이 자란다.
```

### "다른 생각"이란

여기서 "다른 생각"은 **문법의 차이가 아니라 아이디어의 차이**를 뜻합니다.

| 다른 문법 (X) | 다른 생각 (O) |
|---------------|--------------|
| `for i in range(n)` vs `while i < n` | 하나씩 세기 vs 수학 공식 유도 |
| `list.append()` vs `list += [x]` | 완전 탐색 vs 집합(set) 활용 |
| `f-string` vs `.format()` | 정렬 후 처리 vs 딕셔너리로 색인 |

플랫폼의 **풀이 갤러리** 기능은 AI가 학생 풀이의 접근법을 자동으로 분류하고, 학생들이 서로의 코드를 비교하며 토론할 수 있도록 설계되어 있습니다. 따라서 문제 자체가 **분류할 만한 접근법의 다양성**을 내포해야 합니다.

---

## 2. 출제 원칙

### 원칙 1: 손으로 풀 수 없는 규모

코드가 필요한 이유가 분명해야 합니다. "3개의 숫자 중 최댓값을 구하세요"는 머릿속으로 풀 수 있습니다. 하지만 "10,000개의 숫자에서 조건을 만족하는 쌍을 모두 찾으세요"는 코드 없이는 불가능합니다.

- **입력 크기를 충분히 키워서** 손 계산이 비현실적이게 만드세요.
- 테스트 케이스에 **작은 예시(이해용)**와 **큰 입력(코드 필수용)**을 모두 포함하세요.
- 단, Pyodide(브라우저 실행)의 한계를 고려하여 **입력 크기가 10만을 넘지 않도록** 합니다.

### 원칙 2: 최소 2~3가지 서로 다른 사고 방식

문제를 설계할 때 반드시 **접근법을 미리 2~3가지 이상** 구상하고, 이를 문제 JSON의 `expected_approaches` 필드에 기록하세요.

접근법은 **아이디어 수준의 차이**여야 합니다:
- 완전 탐색 vs 수학적 공식
- 정렬 후 처리 vs 딕셔너리 색인
- 재귀 vs 반복
- 누적 계산 vs 한 번에 계산

```json
"expected_approaches": [
  { "tag": "완전 탐색 O(n^2)", "description": "이중 for문으로 모든 쌍 확인" },
  { "tag": "세트 활용 O(n)", "description": "seen에 본 수를 저장, target-n이 seen에 있으면 정답" },
  { "tag": "정렬 + 투 포인터 O(n log n)", "description": "정렬 후 양쪽 끝에서 좁혀가며 탐색" }
]
```

### 원칙 3: 성능 차이가 체감되면 더 좋다

Lv.3 이상의 문제에서는, **비효율적인 접근법이 느리게 동작하는 것을 학생이 직접 체감**할 수 있으면 교육 효과가 극대화됩니다.

- 테스트 케이스에 **큰 입력(n=5000~10000)**을 포함하세요.
- 완전 탐색(O(n^2))은 느리게, 최적화된 풀이(O(n), O(n log n))는 빠르게 통과하도록 설계하세요.
- 단, **모든 접근법이 정답을 받을 수 있어야** 합니다 (시간 초과로 탈락시키지 않습니다). 성능 차이는 갤러리에서 비교 토론의 재료가 됩니다.

### 원칙 4: 고등학생 수준에 맞는 난이도

- **수학적 배경지식을 최소화**하세요. 고등학교 수학 I, II 범위를 넘는 개념은 문제 설명에서 충분히 안내해야 합니다.
- **일상적인 맥락(게임, 학교, SNS 등)**을 활용하면 동기 부여에 효과적입니다.
- 문제 설명에 **예시를 최소 2개** 포함하고, 하나는 손으로 따라갈 수 있을 만큼 작은 입력이어야 합니다.
- 새로운 개념이 필요한 경우 문제 설명에 **개념 설명을 포함**하세요 (에라토스테네스의 체, 시저 암호 등).

### 원칙 5: 명확한 입출력 형식

- 입력과 출력의 형식을 **정확히 명시**하세요.
- 엣지 케이스를 **예시에 포함**하세요 (빈 입력, 최솟값, 동률 등).
- "쌍이 없으면 `없음` 출력" 같은 예외 처리도 명확하게 안내하세요.

---

## 3. 접근법 유형 분류

문제를 설계할 때 아래 유형을 참고하여 **서로 다른 유형의 접근법이 가능하도록** 문제를 만드세요.

### 3.1 완전 탐색 (Brute Force)

모든 경우를 하나하나 확인하는 방법입니다. 가장 직관적이지만 느릴 수 있습니다.

- **키워드**: 이중 for문, 모든 조합, 모든 경우의 수
- **고등학생 친화도**: 높음 (가장 먼저 떠올리기 쉬움)
- **적합 레벨**: 모든 레벨 (기본 접근법으로)

```python
# 예: 리스트에서 합이 target인 두 수 찾기
for i in range(len(nums)):
    for j in range(i+1, len(nums)):
        if nums[i] + nums[j] == target:
            print(nums[i], nums[j])
```

### 3.2 패턴/규칙 발견

데이터에서 반복되는 규칙이나 패턴을 발견하여 효율적으로 풀기.

- **키워드**: 규칙 찾기, 주기, 나머지 연산
- **고등학생 친화도**: 중간 (관찰력 필요)
- **적합 레벨**: Lv.2~4

```python
# 예: n번째 피보나치 수의 마지막 자릿수
# 마지막 자릿수는 60개 주기로 반복 (피사노 주기)
# 직접 계산하지 않고 패턴표를 활용할 수 있음
```

### 3.3 수학적 사고

수학 공식이나 성질을 활용하여 계산을 단순화하기.

- **키워드**: 등차수열 합, 약수, 소인수분해, 조합론
- **고등학생 친화도**: 중간~높음 (수학 실력에 따라 다름)
- **적합 레벨**: Lv.1~4

```python
# 예: 1부터 n까지 홀수의 합
# 완전 탐색: sum(i for i in range(1, n+1) if i % 2 == 1)
# 수학 공식: ((n + 1) // 2) ** 2
```

### 3.4 분할 정복

큰 문제를 작은 부분으로 나누어 해결한 뒤 합치기.

- **키워드**: 반으로 나누기, 재귀, 합치기
- **고등학생 친화도**: 낮음~중간 (재귀 개념이 어려울 수 있음)
- **적합 레벨**: Lv.3~5

```python
# 예: 거듭제곱 빠르게 계산하기
def power(base, exp):
    if exp == 0: return 1
    if exp % 2 == 0:
        half = power(base, exp // 2)
        return half * half
    return base * power(base, exp - 1)
```

### 3.5 누적/메모이제이션

이전 계산 결과를 저장하여 중복 계산을 피하기.

- **키워드**: 누적합, 캐시, 메모, DP
- **고등학생 친화도**: 중간 (개념은 쉽지만 적용이 어려울 수 있음)
- **적합 레벨**: Lv.3~5

```python
# 예: 피보나치 수열 — 메모이제이션 vs 단순 재귀
memo = {}
def fib(n):
    if n in memo: return memo[n]
    if n <= 1: return n
    memo[n] = fib(n-1) + fib(n-2)
    return memo[n]
```

### 3.6 자료구조 활용

딕셔너리, 집합(set), 스택, 큐 등을 활용하여 탐색/저장을 효율화하기.

- **키워드**: dict, set, 스택, 빈도수, 색인
- **고등학생 친화도**: 중간 (dict/set은 비교적 쉬움)
- **적합 레벨**: Lv.2~5

```python
# 예: 리스트에서 중복 원소 찾기
# 완전 탐색: 이중 for문 O(n^2)
# set 활용: seen = set(); if x in seen: → O(n)
```

### 3.7 정렬 활용

데이터를 정렬한 뒤 문제를 단순화하기.

- **키워드**: sort, sorted, 정렬 후 탐색
- **고등학생 친화도**: 높음 (정렬 개념은 직관적)
- **적합 레벨**: Lv.2~4

```python
# 예: 카드 게임에서 최적 전략
cards.sort(reverse=True)
alice = sum(cards[::2])
bob = sum(cards[1::2])
```

---

## 4. 레벨별 출제 가이드

플랫폼의 난이도는 5단계입니다. 각 레벨의 출제 방향을 안내합니다.

### Lv.1 입문 (입문자)

**대상**: 파이썬을 처음 배우는 학생

| 항목 | 기준 |
|------|------|
| 사용 문법 | `print`, `input`, `int()`, `if/elif/else`, 기본 `for`, 산술 연산 |
| 접근법 수 | 최소 2가지 |
| 성능 차이 | 체감 불필요 |
| 입력 규모 | 단일 값 또는 소수의 값 |
| 코드 길이 | 5~15줄 |

**접근법 차이의 예**:
- `if/elif` 분기 vs 산술 연산으로 한 줄 처리
- `for` 반복문 vs 문자열 곱셈(`*`)
- 변수 여러 개 vs 리스트 하나

**출제 팁**:
- 일상적인 상황을 소재로 하세요 (급식비 계산, 학년 판별, BMI 계산 등)
- 정답 코드가 3~5줄 이내면 접근법 차이를 만들기 어렵습니다. **최소 10줄 이상의 풀이가 가능한 규모**로 설계하세요.

### Lv.2 기초 (초보자)

**대상**: 반복문과 조건문에 익숙해진 학생

| 항목 | 기준 |
|------|------|
| 사용 문법 | 중첩 반복문, 문자열 메서드, 리스트 기본, `range()` 활용 |
| 접근법 수 | 2~3가지 |
| 성능 차이 | 가능하면 언급 |
| 입력 규모 | n = 100~1000 |
| 코드 길이 | 10~25줄 |

**접근법 차이의 예**:
- 반복문으로 일일이 세기 vs 내장 함수(`sum`, `count`, `sorted`)
- 문자열 순회 vs 슬라이싱
- 완전 탐색 vs 수학 공식

**출제 팁**:
- FizzBuzz, 회문 판별, 문자 빈도 세기 같은 **고전적 문제**가 이 레벨에 적합합니다.
- `range()` 의 세 번째 인자(step)를 활용할 수 있는 문제를 포함하세요.

### Lv.3 도전 (도전자)

**대상**: 리스트, 함수를 활용할 수 있는 학생

| 항목 | 기준 |
|------|------|
| 사용 문법 | 리스트 컴프리헨션, 함수 정의, 딕셔너리 기초, 문자열 고급 처리 |
| 접근법 수 | 최소 3가지 |
| 성능 차이 | **체감 가능하게** (큰 테스트 케이스 포함) |
| 입력 규모 | n = 1000~10000 |
| 코드 길이 | 15~40줄 |

**접근법 차이의 예**:
- 완전 탐색 O(n^2) vs 정렬 활용 O(n log n) vs 딕셔너리/세트 활용 O(n)
- 반복문 vs 재귀
- 문자열 처리 vs 리스트 변환 후 처리

**출제 팁**:
- **이 레벨이 "같은 문제, 다른 생각"의 핵심 레벨**입니다. 접근법 간 차이가 가장 극명하게 드러나도록 설계하세요.
- "두 수의 합 찾기", "아나그램 판별", "런렝스 인코딩" 같은 문제가 좋은 예입니다.
- 갤러리에서 토론할 **비교 포인트**를 미리 구상하세요.

### Lv.4 심화 (문제해결자)

**대상**: 알고리즘적 사고를 시작하는 학생

| 항목 | 기준 |
|------|------|
| 사용 문법 | 딕셔너리 고급, 재귀, 클래스 기초, 파일/데이터 처리 |
| 접근법 수 | 3가지 이상 |
| 성능 차이 | **명확한 시간복잡도 차이** |
| 입력 규모 | n = 5000~50000 |
| 코드 길이 | 20~60줄 |

**접근법 차이의 예**:
- 단순 반복 vs 에라토스테네스의 체 (소수)
- 재귀 vs 메모이제이션 vs 반복 DP
- 리스트 탐색 vs 이진 탐색
- 그래프 표현 (인접 행렬 vs 인접 리스트)

**출제 팁**:
- 알고리즘 개념(이진 탐색, 소수 판별, 그래프 탐색 등)이 등장하되, **문제 설명에서 개념을 충분히 소개**하세요.
- 같은 결과를 내지만 **자료구조 선택에 따라 효율성이 달라지는** 문제가 좋습니다.

### Lv.5 마스터 (코딩대마왕)

**대상**: 알고리즘에 흥미를 느끼는 상위권 학생

| 항목 | 기준 |
|------|------|
| 사용 문법 | 고급 자료구조, 알고리즘 설계 패턴, 최적화 |
| 접근법 수 | 2가지 이상 (접근법 자체의 난이도가 높음) |
| 성능 차이 | **시간복잡도 차이 극대화** (O(2^n) vs O(n^2) vs O(n log n)) |
| 입력 규모 | n = 10000~100000 |
| 코드 길이 | 30줄 이상 |

**접근법 차이의 예**:
- 재귀(지수 시간) vs DP(다항 시간)
- BFS vs DFS vs 다익스트라
- 브루트포스 vs 이진 탐색 응용
- 다양한 DP 점화식 설계

**출제 팁**:
- 이 레벨은 **접근법의 수보다 접근법의 깊이**가 중요합니다.
- "같은 DP 문제지만 점화식을 어떻게 세우느냐에 따라 코드가 완전히 달라지는" 유형이 좋습니다.
- 고등학생 중 정보 올림피아드에 관심 있는 학생을 위한 레벨이므로, **도전 의욕을 자극하는 이야기**를 입히세요.

---

## 5. 좋은 문제 예시

### 예시 1: 홀수의 합 (Lv.1)

> **문제**: n을 입력받아 1부터 n까지 홀수의 합을 출력하세요.

| 접근법 | 핵심 아이디어 | 시간복잡도 |
|--------|-------------|-----------|
| for + if 필터 | `for i in range(1, n+1): if i % 2 == 1: total += i` | O(n) |
| range 스텝 활용 | `sum(range(1, n+1, 2))` — range의 세 번째 인자 활용 | O(n) |
| 수학 공식 | 홀수의 합 = `((n+1)//2) ** 2` — 반복 없이 계산 | O(1) |

**출제 포인트**: 세 접근법 모두 같은 답을 내지만, "하나씩 세기", "도구 활용", "수학적 사고"라는 근본적으로 다른 사고 방식을 보여줍니다. 갤러리에서 수학 공식을 발견한 학생의 풀이를 보며 "왜 이게 되는 거지?"라는 토론이 자연스럽게 이어집니다.

---

### 예시 2: 두 수의 합 찾기 (Lv.3)

> **문제**: 숫자 목록에서 합이 목표값이 되는 두 수를 찾으세요.

| 접근법 | 핵심 아이디어 | 시간복잡도 |
|--------|-------------|-----------|
| 완전 탐색 | 이중 for문으로 모든 쌍을 확인 | O(n^2) |
| 세트(set) 활용 | `target - x`가 이미 본 수에 있는지 확인 | O(n) |
| 정렬 + 투 포인터 | 정렬 후 양쪽 끝에서 좁혀가며 탐색 | O(n log n) |

**출제 포인트**: n=10이면 모든 방법이 즉시 끝나지만, n=10,000이면 완전 탐색은 느려집니다. "왜 느린지"를 직접 체감한 학생이 "더 빠른 방법은 없을까?"를 자연스럽게 고민하게 됩니다. 세 접근법의 코드를 나란히 놓으면 **자료구조 선택이 성능을 결정한다**는 통찰을 줍니다.

---

### 예시 3: 카드 게임 전략 (Lv.3)

> **문제**: N장의 카드를 두 플레이어가 번갈아 가져갈 때, 점수 차이를 구하세요.

| 접근법 | 핵심 아이디어 | 시간복잡도 |
|--------|-------------|-----------|
| 정렬 + 슬라이싱 | `sorted()[::2]`와 `[1::2]`로 분리하여 합산 | O(n log n) |
| 정렬 + 인덱스 반복 | 정렬 후 `i % 2`로 분배 | O(n log n) |
| 시뮬레이션 | 매 턴 `max()`로 최대 카드를 제거하며 진행 | O(n^2) |

**출제 포인트**: "정렬 후 처리"와 "실제 게임을 흉내내기"라는 사고 방식의 차이가 핵심입니다. 시뮬레이션 접근법은 직관적이지만 비효율적이고, 정렬 접근법은 "둘 다 최선의 전략 = 가장 큰 카드부터 가져감"이라는 통찰이 필요합니다. 슬라이싱을 활용하면 코드가 극적으로 짧아지는 것도 좋은 토론 포인트입니다.

---

### 예시 4: 소수 찾기 (Lv.4)

> **문제**: 2부터 n까지의 모든 소수를 출력하세요.

| 접근법 | 핵심 아이디어 | 시간복잡도 |
|--------|-------------|-----------|
| 하나씩 판별 | 각 수마다 2~sqrt(k)로 나누어 소수 여부 확인 | O(n * sqrt(n)) |
| 에라토스테네스의 체 | 불리언 배열에서 배수를 지워나감 | O(n log log n) |
| 6k +/- 1 최적화 | 소수는 6의 배수 양옆에만 존재한다는 성질 활용 | O(n * sqrt(n)) (상수 개선) |

**출제 포인트**: "각각 독립적으로 판별하기" vs "한꺼번에 거르기"라는 근본적인 발상 차이를 보여줍니다. n=50,000 정도의 테스트 케이스에서 에라토스테네스의 체가 압도적으로 빠른 것을 체감할 수 있습니다. 문제 설명에서 에라토스테네스의 체 알고리즘을 소개하는 것이 좋습니다.

---

### 예시 5: 동전 교환 (Lv.5)

> **문제**: 주어진 종류의 동전으로 목표 금액을 만드는 최소 동전 수를 구하세요.

| 접근법 | 핵심 아이디어 | 시간복잡도 |
|--------|-------------|-----------|
| 그리디(탐욕법) | 큰 동전부터 최대한 사용 (특정 경우 오답 가능) | O(k) |
| 완전 탐색(재귀) | 모든 조합을 시도하여 최솟값 찾기 | O(k^n) (지수) |
| DP (동적 프로그래밍) | `dp[i] = i원을 만드는 최소 동전 수`를 점화식으로 계산 | O(n * k) |

**출제 포인트**: 그리디 접근법이 직관적이지만 **항상 최적이 아닐 수 있다**는 것을 발견하는 순간이 이 문제의 핵심 학습 지점입니다. 예를 들어 동전이 `[1, 3, 4]`이고 목표가 `6`일 때, 그리디는 `4+1+1=3개`이지만 최적은 `3+3=2개`입니다. 이런 반례를 테스트 케이스에 포함하면 학생들이 "왜 그리디가 안 되는지"를 직접 발견합니다.

---

## 6. 피해야 할 문제 유형

### 6.1 답이 하나뿐인 문제

```
나쁜 예: "Hello, World!"를 출력하세요.
→ print("Hello, World!")만 가능. 사고력이 아니라 타이핑 연습.
```

정답 코드가 사실상 하나뿐이라면, 갤러리에서 비교할 것이 없습니다.

### 6.2 문법만 다른 문제

```
나쁜 예: 변수 a와 b를 교환하세요.
→ a, b = b, a / temp 사용 / 산술 연산 사용
→ 세 방법 모두 "교환"이라는 같은 아이디어. 사고의 차이가 아님.
```

접근법이 겉보기에 다르더라도 **근본적인 아이디어가 같다면** 이 플랫폼에 적합하지 않습니다.

### 6.3 손으로 풀 수 있는 규모

```
나쁜 예: 3개의 숫자 중 가장 큰 수를 출력하세요.
→ 머릿속으로 비교 가능. 코드를 쓸 동기 부여가 안 됨.
```

입력 규모가 작으면 학생들이 "이걸 왜 코드로 풀어야 하지?"라는 의문을 갖습니다.

### 6.4 지식 의존형 문제

```
나쁜 예: 정규표현식으로 이메일 주소를 검증하세요.
→ 정규표현식을 아느냐 모르느냐의 문제. 사고력이 아닌 암기.
```

특정 라이브러리나 고급 문법의 존재 여부를 아는 것이 핵심인 문제는 피하세요.

### 6.5 디버깅/오류 찾기 문제

```
나쁜 예: 다음 코드의 버그를 찾으세요.
→ 다양한 접근법이 아니라 하나의 정답을 찾는 문제.
```

이 플랫폼은 "내 코드를 작성하는" 경험에 집중합니다. 남의 코드를 고치는 문제는 적합하지 않습니다.

### 6.6 출력 형식에 과도하게 의존하는 문제

```
나쁜 예: 다음과 정확히 같은 형태로 표를 출력하세요. (공백, 정렬 등)
→ 사고력이 아니라 포맷팅 노가다.
```

출력 형식 맞추기에 시간을 쏟게 되면 **핵심 사고**에서 멀어집니다. 출력 형식은 최대한 단순하게 설계하세요.

---

## 7. 문제 JSON 작성 체크리스트

문제를 `server/data/problems/` 디렉토리에 JSON 파일로 추가할 때, 아래 항목을 확인하세요.

```
[ ] id: 'lv{레벨}-{번호}-{영문이름}' 형식 (예: lv3-13-twoSum)
[ ] title: 한국어 제목
[ ] difficulty: 1~5 숫자
[ ] category: output / logic / loop / string / list / function / algorithm
[ ] description: 문제 설명 (마크다운). 예시 최소 2개 포함
[ ] starter_code: 학생이 처음 보게 되는 코드 (입력 처리 포함)
[ ] test_cases: 최소 3개 (기본, 엣지, 큰 입력)
[ ] hints: 3단계 힌트 (질문 → 방향 → 구체적 접근)
[ ] expected_approaches: 최소 2개 (tag + description)
[ ] explanation: 풀이 해설 (마크다운). 여러 접근법의 코드 포함
```

### expected_approaches 작성 가이드

```json
"expected_approaches": [
  {
    "tag": "간결한 접근법 이름",
    "description": "이 접근법의 핵심 아이디어를 한 문장으로"
  }
]
```

- `tag`는 갤러리에서 학생 풀이를 분류할 때 사용됩니다.
- AI가 학생 코드를 분석하여 가장 가까운 tag를 매칭하므로, **명확하고 구분 가능한 이름**을 사용하세요.
- 가능하면 시간복잡도를 포함하세요: `"완전 탐색 O(n^2)"`, `"세트 활용 O(n)"`

### hints 작성 가이드

힌트는 3단계로 설계합니다. AI 코치의 도움 수준(`QUESTIONS_ONLY` → `CONCEPTUAL_HINT` → `PSEUDOCODE`)과 대응됩니다.

1. **1단계 (질문)**: 방향만 제시하는 질문 — "이 데이터를 먼저 정렬하면 어떨까요?"
2. **2단계 (방향)**: 핵심 개념 언급 — "딕셔너리를 사용하면 검색이 O(1)이 됩니다"
3. **3단계 (구체)**: 거의 수도코드 수준 — "for n in numbers: if target-n in seen: 정답!"

---

## 8. 요약: 좋은 문제의 5가지 특징

1. **다경로성** — 최소 2~3가지 근본적으로 다른 사고 방식으로 풀 수 있다
2. **코드 필요성** — 손으로 풀기엔 규모가 크다 (코드를 쓸 이유가 명확하다)
3. **비교 가능성** — 접근법을 나란히 놓으면 "이 방법이 왜 더 나은지"가 보인다
4. **적정 난이도** — 해당 레벨 학생이 최소 하나의 접근법으로는 풀 수 있다
5. **토론 유발성** — 갤러리에서 "나는 이렇게 했는데 넌 왜 그렇게 했어?"라는 대화가 생긴다

---

*이 가이드라인은 "사고력을 위한 파이썬" 플랫폼의 출제 품질을 일관되게 유지하기 위해 작성되었습니다. 새로운 문제를 만들 때마다 이 문서를 참고해 주세요.*
